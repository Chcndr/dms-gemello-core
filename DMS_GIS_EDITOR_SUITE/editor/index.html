<!doctype html>
<html>
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>DMS GIS Editor ‚Äî Trasparenza ‚Ä¢ Overlay ‚Ä¢ GCP ‚Ä¢ GeoJSON</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
  :root{
    --bg:#0b1c26;--panel:#0f2330;--txt:#eaf1f5;--mut:#9fb1be;--acc:#1f8f5f
  }
  html,body,#map{height:100%;margin:0}
  /* MAPPA piena */
  #map{position:relative; z-index:1}

  /* SIDEBAR fissa, stretta, scrollabile e sempre sopra */
  .ui{
    position:fixed;           /* non pi√π absolute */
    top:12px; left:12px;
    width:360px;              /* ~360px desktop */
    max-width:min(92vw,420px);
    height:calc(100% - 24px); /* occupa tutta l'altezza */
    overflow:auto;            /* scroll interno */
    background:var(--panel); color:var(--txt);
    padding:14px 14px 18px;
    border-radius:12px;
    box-shadow:0 10px 28px rgba(0,0,0,.35);
    font:14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    z-index:10000;            /* SEMPRE sopra alla mappa */
    transition:transform .25s ease;
  }
  .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  input[type=range]{width:100%}
  input[type=file]{display:block;margin-top:6px}
  button{background:var(--acc);border:0;color:#fff;padding:8px 10px;border-radius:8px;cursor:pointer}
  button.secondary{background:#2b3c48} button.danger{background:#b84040}
  .small{font-size:12px} .mut{color:var(--mut)}
  .group{border-top:1px solid #1a2d3a;margin-top:10px;padding-top:10px}
  #log{max-height:120px;overflow:auto;background:#08131a;border-radius:8px;padding:6px;font-family:ui-monospace,monospace;margin-top:6px}
  .btnLink{display:inline-block;background:var(--acc);color:#fff;padding:8px 10px;border-radius:8px;text-decoration:none;font-size:13px;cursor:pointer}
  .btnLink:hover{background:#25a570}

  /* TOGGLE (hamburger) fisso nell'angolo */
  .toggle{
    position:fixed; top:12px; left:12px;
    z-index:10001;            /* sopra alla sidebar stessa */
    background:#2b3c48; color:#fff; border:0; border-radius:10px;
    padding:8px 10px; cursor:pointer; box-shadow:0 4px 16px rgba(0,0,0,.25);
  }
  /* Quando collasso, sposto la sidebar fuori schermo */
  body.ui-collapsed .ui{ transform:translateX(calc(-100% - 16px)); }
  /* Su schermi stretti parto gi√† collassato per lasciare la mappa libera */
  @media (max-width: 900px){
    .ui{ width:min(92vw,420px); }
    body:not(.ui-opened-once) .ui{ transform:translateX(calc(-100% - 16px)); }
  }
  /* Far respirare la mappa quando sidebar aperta */
  body:not(.ui-collapsed) .leaflet-left{
    left:388px;               /* 360 + padding */
    transition:left .25s ease;
  }
  @media (max-width: 900px){
    body:not(.ui-collapsed) .leaflet-left{ left:12px; }
  }

  /* MODALE PNG TRASPARENZA */
  .png-modal{
    display:none; position:fixed; top:0; left:0; width:100%; height:100%;
    background:var(--bg); z-index:20000;
  }
  .png-modal.active{ display:flex; }
  .png-modal-sidebar{
    width:360px; background:var(--panel); padding:20px; overflow-y:auto;
    border-right:1px solid #1a3a4a; color:var(--txt);
  }
  .png-modal-sidebar label{ color:var(--txt); display:block; margin-top:12px; font-size:13px; }
  .png-modal-sidebar .small{ color:#b0c4d0; }
  .png-modal-sidebar input[type=range]{ width:100%; margin-top:4px; }
  .png-modal-sidebar input[type=checkbox]{ width:auto; margin-right:8px; }
  .png-modal-canvas{
    flex:1; display:flex; flex-direction:column; padding:20px; overflow:auto;
  }
  .png-modal-canvas-container{
    display:grid; grid-template-columns:1fr 1fr; gap:20px; flex:1;
  }
  .png-modal-canvas-wrapper{
    display:flex; flex-direction:column; background:var(--panel);
    border-radius:12px; padding:16px; min-height:0;
  }
  .png-modal-canvas-wrapper h3{
    font-size:14px; margin-bottom:12px; color:#4fc3a0;
  }
  .png-modal-canvas-wrapper canvas{
    width:100%; height:100%; object-fit:contain; background:#111;
    border:1px solid #223; border-radius:8px;
  }
  .png-modal-close{
    position:absolute; top:20px; right:20px; background:#b84040;
    border:0; color:#fff; padding:10px 14px; border-radius:8px;
    cursor:pointer; font-size:16px; z-index:20001;
  }
  @media (max-width: 900px){
    .png-modal-canvas-container{ grid-template-columns:1fr; }
  }
</style>
</head>
<body>
<button id="togglePanel" class="toggle" title="Apri/chiudi pannello">‚ò∞</button>
<div id="map"></div>

<div class="ui">
  <b>1) Carica Pianta (PNG/JPG o PDF)</b>
  <input id="file" type="file" accept="image/*,application/pdf"/>

  <div class="row" style="margin-top:6px">
    <button id="pick" class="secondary" title="Clicca sulla preview per campionare il verde">üéØ Contagocce</button>
    <button id="downloadPng" class="secondary">‚¨áÔ∏è PNG trasparente</button>
  </div>

  <label>Hue min/max <span id="hvals" class="small"></span></label>
  <input id="hmin" type="range" min="0" max="360" value="70">
  <input id="hmax" type="range" min="0" max="360" value="160">

  <label>Saturazione minima <span id="sval" class="small"></span></label>
  <input id="smin" type="range" min="0" max="100" value="25">

  <label>Luminosit√† minima <span id="vval" class="small"></span></label>
  <input id="vmin" type="range" min="0" max="100" value="25">

  <label><input type="checkbox" id="keepDigits" checked> Mantieni numeri/contorni scuri</label>

  <label>Pulizia/chiusura buchi <span id="cleanVal" class="small"></span></label>
  <input id="cleanIter" type="range" min="0" max="3" value="1">

  <label>Despeckle (rimuovi puntini) <span id="despeckleVal" class="small"></span></label>
  <input id="despeckle" type="range" min="0" max="2" value="1">

  <div class="row">
    <button id="applyAlpha" class="secondary">‚Üª Applica</button>
    <button id="fixOverlay">üìå Fissa</button>
    <button id="unlock" class="secondary">‚úèÔ∏è Sblocca</button>
  </div>

  <div class="row">
    <button id="exportGCP" class="secondary">‚¨áÔ∏è Esporta GCP</button>
    <button id="clear" class="danger">üßπ Pulisci</button>
  </div>

  <details style="margin-top:8px">
    <summary class="small">Anteprima cromakey</summary>
    <canvas id="preview" style="width:100%;background:#0c141a;border-radius:8px;border:1px solid #20303c"></canvas>
  </details>

  <div class="group">
    <b>2) Container (px) ‚Üí GeoJSON</b>
    <div class="mut small" style="margin-top:4px">
      Carica un <code>container.json</code> con <code>area_px</code> e <code>stalls_px</code> in pixel dell‚Äôimmagine (vedi sample).
      Posiziona la pianta, poi applica i GCP per georeferenziare e genera i GeoJSON.
    </div>
    <input type="file" id="containerInput" accept="application/json"/>
    <div class="row" style="margin-top:6px">
      <button id="btnApply">Applica GCP ‚Üí mappa</button>
      <button id="btnExportArea" class="secondary">‚¨áÔ∏è Area GeoJSON</button>
      <button id="btnExportStalls" class="secondary">‚¨áÔ∏è Stalls GeoJSON</button>
    </div>
    <div id="log"></div>
  </div>

  <div class="group">
    <b>Strumenti rapidi</b>
    <div class="row">
      <a class="btnLink" href="../tools/stalls_alpha_tool.html" target="_blank">PNG Trasparente</a>
      <a class="btnLink" href="/dms-gemello-core/DMS_GIS_CONTAINER_KIT/demo/index.html?locale=it" target="_blank">GIS Container Kit</a>
      <a class="btnLink" href="/dms-gemello-core/area-editor.html" target="_blank">Area Editor</a>
      <a class="btnLink" href="/dms-gemello-core/slot-editor.html" target="_blank">Slot Editor</a>
    </div>
    <div class="small mut" style="margin-top:6px">Si aprono in una nuova scheda.</div>
  </div>
</div>

<!-- MODALE PNG TRASPARENZA -->
<div id="pngModal" class="png-modal">
  <button id="closePngModal" class="png-modal-close">‚úï Chiudi</button>
  <div class="png-modal-sidebar">
    <h2 style="font-size:18px;margin-bottom:16px;color:#4fc3a0">üé® PNG Trasparente</h2>
    <p style="font-size:12px;opacity:0.8;margin-bottom:16px">Regola i parametri e scarica quando sei soddisfatto</p>
    
    <label>Hue Min/Max <span id="modalHvals" class="small"></span></label>
    <input id="modalHmin" type="range" min="0" max="360" value="70">
    <input id="modalHmax" type="range" min="0" max="360" value="160">
    
    <label>Saturation Min <span id="modalSval" class="small"></span></label>
    <input id="modalSmin" type="range" min="0" max="100" value="25">
    
    <label>Value Min <span id="modalVval" class="small"></span></label>
    <input id="modalVmin" type="range" min="0" max="100" value="25">
    
    <label><input type="checkbox" id="modalKeepDigits" checked> Mantieni numeri scuri</label>
    
    <label>Pulizia/chiusura buchi <span id="modalCleanVal" class="small"></span></label>
    <input id="modalCleanIter" type="range" min="0" max="3" value="1">
    
    <label>Despeckle <span id="modalDespeckleVal" class="small"></span></label>
    <input id="modalDespeckle" type="range" min="0" max="2" value="1">
    
    <button id="rotateImageBtn" style="width:100%;margin-top:16px;background:#2b7a9a">üîÑ Ruota 90¬∞</button>
    <button id="applyFromModal" style="width:100%;margin-top:8px;background:#4fc3a0">‚úÖ Applica sulla Mappa</button>
    <button id="downloadFromModal" style="width:100%;margin-top:8px">üì• Scarica PNG</button>
  </div>
  <div class="png-modal-canvas">
    <div class="png-modal-canvas-container">
      <div class="png-modal-canvas-wrapper">
        <h3>üì∑ Originale</h3>
        <canvas id="modalSrc"></canvas>
      </div>
      <div class="png-modal-canvas-wrapper">
        <h3>‚ú® Risultato (Trasparenza Applicata)</h3>
        <canvas id="modalDst"></canvas>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.distortableimage@0.12.0/dist/leaflet.distortableimage.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.min.js"></script>
<script>
/* ===================== MAPPA ===================== */
const map=L.map('map').setView([42.7633,11.1117],17);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:20}).addTo(map);
map.createPane('area'); map.getPane('area').style.zIndex=450;
map.createPane('stalls'); map.getPane('stalls').style.zIndex=460;

/* ===================== UI state ===================== */
let overlay=null, pxSize=null, lastAlphaDataURL=null, picking=false;
const file=document.getElementById('file'), hmin=document.getElementById('hmin'), hmax=document.getElementById('hmax'),
      smin=document.getElementById('smin'), vmin=document.getElementById('vmin'), keepDigits=document.getElementById('keepDigits'),
      cleanIter=document.getElementById('cleanIter'), despeckle=document.getElementById('despeckle'),
      hvals=document.getElementById('hvals'), sval=document.getElementById('sval'), vval=document.getElementById('vval'),
      cleanVal=document.getElementById('cleanVal'), despeckleVal=document.getElementById('despeckleVal'),
      preview=document.getElementById('preview'), pickBtn=document.getElementById('pick'), logEl=document.getElementById('log');
const img=new Image(); let srcCanvas=document.createElement('canvas'), srcCtx=srcCanvas.getContext('2d',{willReadFrequently:true});
let currentContainer=null, areaLayer=null, stallsLayer=null;

/* ===================== LOG helper ===================== */
function log(msg){const t=new Date().toTimeString().slice(0,8); logEl.innerText = `[${t}] ${msg}\n` + logEl.innerText}

/* ===================== CARICA PLANTA ===================== */
file.onchange=async()=>{
  const f=file.files[0]; if(!f) return;
  if(f.type==='application/pdf'){
    const buf=await f.arrayBuffer();
    const pdf=await pdfjsLib.getDocument({data:buf}).promise;
    const page=await pdf.getPage(1);
    const v=page.getViewport({scale:2});
    const cnv=document.createElement('canvas'); cnv.width=v.width; cnv.height=v.height;
    await page.render({canvasContext:cnv.getContext('2d'),viewport:v}).promise;
    img.onload=()=>{pxSize={w:img.naturalWidth,h:img.naturalHeight}; drawAlpha(); placeOverlay(); log('PDF caricato.');};
    img.src=cnv.toDataURL('image/png');
  } else {
    img.onload=()=>{pxSize={w:img.naturalWidth,h:img.naturalHeight}; drawAlpha(); placeOverlay(); log('Immagine caricata.');};
    img.src=URL.createObjectURL(f);
  }
};

/* ===================== CONTAGOCCE ===================== */
pickBtn.onclick=()=>{picking=!picking; pickBtn.textContent=picking?'üéØ Tocca la preview‚Ä¶':'üéØ Contagocce'};
preview.addEventListener('click', e=>{
  if(!picking) return;
  const r=preview.getBoundingClientRect();
  const x=Math.floor((e.clientX-r.left)*preview.width/r.width);
  const y=Math.floor((e.clientY-r.top)*preview.height/r.height);
  const pctx=preview.getContext('2d',{willReadFrequently:true});
  const d=pctx.getImageData(x,y,1,1).data;
  const {h}=rgb2hsv(d[0],d[1],d[2]);
  hmin.value=Math.max(0,Math.round(h)-20);
  hmax.value=Math.min(360,Math.round(h)+20);
  smin.value=20; vmin.value=20;
  picking=false; pickBtn.textContent='üéØ Contagocce';
  drawAlpha(true);
});

/* ===================== SLIDER ===================== */
[hmin,hmax,smin,vmin,keepDigits,cleanIter,despeckle].forEach(el=>el.oninput=()=>drawAlpha(true));

/* ===================== BOTTONI BASE ===================== */
document.getElementById('applyAlpha').onclick=()=>drawAlpha(true);
document.getElementById('downloadPng').onclick=()=>{ if(!img.naturalWidth) return alert('Carica prima un\'immagine'); openPngModal(); };
document.getElementById('fixOverlay').onclick=()=>{ if(!overlay) return alert('Nessun overlay'); overlay.editing.disable(); log('Overlay fissato.'); };
document.getElementById('unlock').onclick=()=>{ overlay?.editing.enable(); log('Overlay sbloccato.'); };
document.getElementById('exportGCP').onclick=()=>{ if(!overlay||!pxSize) return alert('Niente GCP'); const ll=overlay.getCornerLatLngs(); const gcp=[{px:[0,0],ll:[ll[0].lat,ll[0].lng]},{px:[pxSize.w,0],ll:[ll[1].lat,ll[1].lng]},{px:[pxSize.w,pxSize.h],ll:[ll[2].lat,ll[2].lng]},{px:[0,pxSize.h],ll:[ll[3].lat,ll[3].lng]}]; downloadJSON({gcp,imageW:pxSize.w,imageH:pxSize.h},'gcp.json'); log('GCP esportati.'); };
document.getElementById('clear').onclick=()=>{ [overlay,areaLayer,stallsLayer].forEach(l=>l&&map.removeLayer(l)); overlay=areaLayer=stallsLayer=null; lastAlphaDataURL=null; preview.width=0; preview.height=0; currentContainer=null; log('Pulito.'); };

/* ===================== CORE: CROMAKEY + OVERLAY ===================== */
function drawAlpha(updateOverlay=false){
  if(!img.naturalWidth) return;
  const W=img.naturalWidth,H=img.naturalHeight;
  srcCanvas.width=W; srcCanvas.height=H;
  const ctx=srcCtx; ctx.drawImage(img,0,0);
  hvals.textContent=`${hmin.value}‚Äì${hmax.value}`; sval.textContent=smin.value; vval.textContent=vmin.value;

  const scale=Math.min(1,1200/W);
  preview.width=Math.round(W*scale); preview.height=Math.round(H*scale);
  const pctx=preview.getContext('2d'); pctx.drawImage(img,0,0,preview.width,preview.height);

  const imgData=ctx.getImageData(0,0,W,H), d=imgData.data;
  const HMIN=+hmin.value,HMAX=+hmax.value,SMIN=+smin.value/100,VMIN=+vmin.value/100;
  for(let i=0;i<d.length;i+=4){
    const {h,s,v}=rgb2hsv(d[i],d[i+1],d[i+2]);
    let keep=(h>=HMIN&&h<=HMAX&&s>=SMIN&&v>=VMIN);
    if(keepDigits.checked){ const lum=0.2126*d[i]+0.7152*d[i+1]+0.0722*d[i+2]; if(lum<90) keep=true; }
    d[i+3]=keep?255:0;
  }
  ctx.putImageData(imgData,0,0);

  // --- smoothing & cleanup opzionali ---
  cleanVal.textContent=cleanIter.value; despeckleVal.textContent=despeckle.value;
  if(+cleanIter.value>0 || +despeckle.value>0){
    let id = ctx.getImageData(0,0,W,H);
    if(+cleanIter.value>0){
      id = closeAlpha(id, W, H, +cleanIter.value); // dilata + erodi => chiude piccoli buchi
    }
    if(+despeckle.value>0){
      id = despeckleAlpha(id, W, H, +despeckle.value); // elimina puntini isolati
    }
    ctx.putImageData(id, 0, 0);
  }

  lastAlphaDataURL=srcCanvas.toDataURL('image/png');

  const tmp=new Image();
  tmp.onload=()=>{ pctx.clearRect(0,0,preview.width,preview.height); pctx.drawImage(tmp,0,0,preview.width,preview.height); };
  tmp.src=lastAlphaDataURL;

  if(updateOverlay) refreshOverlay();
}
function placeOverlay(){ 
  alert('üîç DEBUG: placeOverlay() chiamata!\nCentro mappa: ' + map.getCenter());
  
  const url=lastAlphaDataURL||img.src; 
  if(overlay) map.removeLayer(overlay); 
  
  // Coordinate iniziali centrate su Grosseto
  const center = map.getCenter();
  const bounds = map.getBounds();
  const ne = bounds.getNorthEast();
  const sw = bounds.getSouthWest();
  
  // Creo un rettangolo che occupa circa met√† della vista corrente
  const latDiff = (ne.lat - sw.lat) * 0.25;
  const lngDiff = (ne.lng - sw.lng) * 0.25;
  
  // Creo 4 corner con L.latLng() come richiesto dalla libreria
  const corners = [
    L.latLng(center.lat - latDiff, center.lng - lngDiff), // SW
    L.latLng(center.lat - latDiff, center.lng + lngDiff), // SE
    L.latLng(center.lat + latDiff, center.lng + lngDiff), // NE
    L.latLng(center.lat + latDiff, center.lng - lngDiff)  // NW
  ];
  
  alert('üîç DEBUG: Creo overlay con ' + corners.length + ' corners');
  
  try {
    // Provo a creare overlay SENZA corners iniziali
    overlay = L.distortableImageOverlay(url, {
      editable: true,
      actions: ['distort', 'rotate', 'scale']
    });
    
    alert('üîç DEBUG: Overlay creato (senza corners)');
    
    // Aggiungo alla mappa
    overlay.addTo(map);
    
    alert('üîç DEBUG: Overlay aggiunto alla mappa');
    
    // Ora imposto i corners
    if (overlay.setCorners) {
      overlay.setCorners(corners);
      alert('üîç DEBUG: Corners impostati con setCorners()');
    } else {
      alert('‚ö†Ô∏è ERRORE: overlay.setCorners non esiste!');
    }
    
    alert('‚úÖ DEBUG: Overlay completato! Bounds: ' + overlay.getBounds());
  } catch(err) {
    alert('‚ùå ERRORE nella creazione overlay: ' + err.message);
    console.error('Errore overlay:', err);
  }
  
  setTimeout(()=>{
    map.fitBounds(overlay.getBounds());
    log('Overlay posizionato e mappa centrata.');
    alert('‚úÖ Overlay posizionato e mappa centrata!');
  }, 100);
}
function refreshOverlay(){ if(!overlay){placeOverlay();return;} overlay.setUrl(lastAlphaDataURL); }

/* ===================== CONTAINER ‚Üí GEOJSON ===================== */
document.getElementById('containerInput').onchange=async(e)=>{ const f=e.target.files[0]; if(!f) return; currentContainer=JSON.parse(await f.text()); log('Container caricato.'); };
document.getElementById('btnApply').onclick=()=>{
  if(!currentContainer) return alert('Carica un container JSON');
  if(!overlay||!pxSize) return alert('Posiziona e fissa la pianta (o lasciata modificabile) per avere i GCP');
  const ll=overlay.getCornerLatLngs();
  const gcp=[ {px:{x:0,y:0},           wm:latLngToXY(ll[0])},
              {px:{x:pxSize.w,y:0},     wm:latLngToXY(ll[1])},
              {px:{x:pxSize.w,y:pxSize.h}, wm:latLngToXY(ll[2])},
              {px:{x:0,y:pxSize.h},     wm:latLngToXY(ll[3])} ];

  const H=computeHomography(
    gcp.map(g=>g.px),
    gcp.map(g=>g.wm)
  );

  // Area
  const areaLatLngs = currentContainer.area_px.map(p => fromXY(applyH(H,p[0],p[1])));
  if(areaLayer) map.removeLayer(areaLayer);
  areaLayer = L.polygon(areaLatLngs, {pane:'area', weight:1}).addTo(map);

  // Stalls
  if(stallsLayer) map.removeLayer(stallsLayer);
  stallsLayer = L.featureGroup([], {pane:'stalls'}).addTo(map);
  (currentContainer.stalls_px||[]).forEach(s=>{
    const latlngs = s.poly.map(p => fromXY(applyH(H,p[0],p[1])));
    const poly = L.polygon(latlngs, {weight:1});
    poly.feature = {type:'Feature', properties:{id:s.id}};
    poly.bindTooltip(String(s.id), {direction:'center'});
    stallsLayer.addLayer(poly);
  });
  attachZoomStyling(map, stallsLayer, 18);
  map.fitBounds(areaLayer.getBounds(), {padding:[24,24]});
  log('Georeferenzazione applicata (container ‚Üí mappa).');
};
document.getElementById('btnExportArea').onclick=()=>{ if(!areaLayer) return alert('Nessuna area'); downloadJSON(areaLayer.toGeoJSON(),'area.geojson'); };
document.getElementById('btnExportStalls').onclick=()=>{ if(!stallsLayer) return alert('Nessun layer posteggi'); downloadJSON(stallsLayer.toGeoJSON(),'stalls.geojson'); };

/* ===================== MATH & PROIEZIONI ===================== */
// CRS di Leaflet (Spherical Mercator)
const CRS = L.CRS.EPSG3857;
function latLngToXY(ll){ const p=CRS.project(ll); return {x:p.x,y:p.y}; }
function fromXY(pt){ return CRS.unproject(L.point(pt.x,pt.y)); }

// Omografia 4 punti (px -> world meters)
function solve(A,b){
  const n=A.length;
  for(let i=0;i<n;i++){
    let max=i; for(let r=i+1;r<n;r++) if(Math.abs(A[r][i])>Math.abs(A[max][i])) max=r;
    [A[i],A[max]]=[A[max],A[i]]; [b[i],b[max]]=[b[max],b[i]];
    const div=A[i][i]; for(let j=i;j<n;j++) A[i][j]/=div; b[i]/=div;
    for(let r=0;r<n;r++) if(r!==i){
      const f=A[r][i];
      for(let j=i;j<n;j++) A[r][j]-=f*A[i][j];
      b[r]-=f*b[i];
    }
  }
  return b;
}
function computeHomography(pxs, wms){
  const A=[], b=[];
  for(let k=0;k<4;k++){
    const x=pxs[k].x, y=pxs[k].y, X=wms[k].x, Y=wms[k].y;
    A.push([x,y,1,0,0,0,-x*X,-y*X]); b.push(X);
    A.push([0,0,0,x,y,1,-x*Y,-y*Y]); b.push(Y);
  }
  const h=solve(A,b);
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
}
function applyH(H, x, y){
  const w = H[2][0]*x + H[2][1]*y + H[2][2];
  const X = (H[0][0]*x + H[0][1]*y + H[0][2]) / w;
  const Y = (H[1][0]*x + H[1][1]*y + H[1][2]) / w;
  return {x:X, y:Y};
}

/* ===================== STILE DINAMICO ALLO ZOOM ===================== */
function attachZoomStyling(map, layer, baseZoom){
  baseZoom = baseZoom || 18;
  function restyle(){
    const scale = Math.pow(2, map.getZoom() - baseZoom);
    layer.setStyle?.({weight: Math.max(0.5, 1/scale)});
    document.querySelectorAll('.leaflet-tooltip').forEach(el=>{
      el.style.fontSize = `${Math.max(10, 12/scale)}px`;
    });
  }
  map.on('zoomend', restyle); restyle();
}

/* ===================== UTILITY ===================== */
function downloadJSON(obj, filename){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}
function rgb2hsv(R,G,B){
  const r=R/255,g=G/255,b=B/255;
  const M=Math.max(r,g,b), m=Math.min(r,g,b), C=M-m; let H=0;
  if(C!==0){ if(M===r) H=((g-b)/C)%6; else if(M===g) H=(b-r)/C+2; else H=(r-g)/C+4; H*=60; if(H<0) H+=360; }
  const V=M, S=M===0?0:C/M; return {h:H,s:S,v:V};
}

/* ===================== MORFOLOGIA ALPHA ===================== */
function closeAlpha(imgData, W, H, iters){
  // kernel 3x3 su canale alpha: dilata poi erodi (x iters)
  const k=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
  let id = imgData;
  for(let t=0;t<iters;t++){
    // dilate
    let d = new Uint8ClampedArray(id.data);
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        let idx=(y*W+x)*4; if(d[idx+3]===255) continue;
        for(const [dx,dy] of k){
          const n=((y+dy)*W+(x+dx))*4;
          if(d[n+3]===255){ id.data[idx+3]=255; break; }
        }
      }
    }
    // erode
    d = new Uint8ClampedArray(id.data);
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        let idx=(y*W+x)*4; if(d[idx+3]===0) continue;
        let hasHole=false;
        for(const [dx,dy] of k){
          const n=((y+dy)*W+(x+dx))*4;
          if(d[n+3]===0){ hasHole=true; break; }
        }
        if(hasHole) id.data[idx+3]=0;
      }
    }
  }
  return id;
}

function despeckleAlpha(imgData, W, H, level){
  // rimuove pixel/isolotti molto piccoli contando vicini opachi
  const d = imgData.data;
  const need = level===1?2:3; // vicini minimi per sopravvivere
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const idx=(y*W+x)*4;
      if(d[idx+3]===0) continue;
      let cnt=0;
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          if(dx===0 && dy===0) continue;
          const n=((y+dy)*W+(x+dx))*4; if(d[n+3]===255) cnt++;
        }
      }
      if(cnt<need) d[idx+3]=0;
    }
  }
  return imgData;
}

/* ===================== TOGGLE PANNELLO ===================== */
const toggleBtn = document.getElementById('togglePanel');
function toggleUI(){
  document.body.classList.toggle('ui-collapsed');
  document.body.classList.add('ui-opened-once'); // evita auto-collasso mobile dopo la prima apertura
}
toggleBtn.addEventListener('click', toggleUI);

// All'avvio, assicuro che il pannello sia visibile su desktop
if(window.matchMedia('(min-width: 901px)').matches){
  document.body.classList.remove('ui-collapsed');
}

/* ===================== MODALE PNG TRASPARENZA ===================== */
const pngModal = document.getElementById('pngModal');
const modalSrc = document.getElementById('modalSrc');
const modalDst = document.getElementById('modalDst');
const modalHmin = document.getElementById('modalHmin');
const modalHmax = document.getElementById('modalHmax');
const modalSmin = document.getElementById('modalSmin');
const modalVmin = document.getElementById('modalVmin');
const modalKeepDigits = document.getElementById('modalKeepDigits');
const modalCleanIter = document.getElementById('modalCleanIter');
const modalDespeckle = document.getElementById('modalDespeckle');
const modalHvals = document.getElementById('modalHvals');
const modalSval = document.getElementById('modalSval');
const modalVval = document.getElementById('modalVval');
const modalCleanVal = document.getElementById('modalCleanVal');
const modalDespeckleVal = document.getElementById('modalDespeckleVal');

function openPngModal(){
  if(!img.naturalWidth) return;
  // Copia valori attuali nella modale
  modalHmin.value = hmin.value;
  modalHmax.value = hmax.value;
  modalSmin.value = smin.value;
  modalVmin.value = vmin.value;
  modalKeepDigits.checked = keepDigits.checked;
  modalCleanIter.value = cleanIter.value;
  modalDespeckle.value = despeckle.value;
  
  pngModal.classList.add('active');
  drawModalAlpha();
}

function closePngModal(){
  pngModal.classList.remove('active');
}

function drawModalAlpha(){
  if(!img.naturalWidth) return;
  const W=img.naturalWidth, H=img.naturalHeight;
  modalSrc.width=W; modalSrc.height=H;
  modalDst.width=W; modalDst.height=H;
  
  const srcCtx = modalSrc.getContext('2d');
  srcCtx.drawImage(img,0,0);
  
  const dstCtx = modalDst.getContext('2d');
  dstCtx.drawImage(img,0,0);
  
  const imgData = dstCtx.getImageData(0,0,W,H);
  const d = imgData.data;
  const HMIN=+modalHmin.value, HMAX=+modalHmax.value;
  const SMIN=+modalSmin.value/100, VMIN=+modalVmin.value/100;
  
  modalHvals.textContent = `${HMIN}‚Äì${HMAX}`;
  modalSval.textContent = modalSmin.value;
  modalVval.textContent = modalVmin.value;
  modalCleanVal.textContent = modalCleanIter.value;
  modalDespeckleVal.textContent = modalDespeckle.value;
  
  for(let i=0; i<d.length; i+=4){
    const {h,s,v} = rgb2hsv(d[i], d[i+1], d[i+2]);
    let keep = (h>=HMIN && h<=HMAX && s>=SMIN && v>=VMIN);
    if(modalKeepDigits.checked){
      const lum = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
      if(lum<90) keep=true;
    }
    d[i+3] = keep ? 255 : 0;
  }
  
  // Pulizia morfologica
  if(+modalCleanIter.value>0 || +modalDespeckle.value>0){
    let id = imgData;
    if(+modalCleanIter.value>0){
      id = closeAlpha(id, W, H, +modalCleanIter.value);
    }
    if(+modalDespeckle.value>0){
      id = despeckleAlpha(id, W, H, +modalDespeckle.value);
    }
    dstCtx.putImageData(id, 0, 0);
  } else {
    dstCtx.putImageData(imgData, 0, 0);
  }
}

[modalHmin,modalHmax,modalSmin,modalVmin,modalKeepDigits,modalCleanIter,modalDespeckle].forEach(el=>el.oninput=drawModalAlpha);

document.getElementById('closePngModal').onclick = closePngModal;

let rotationAngle = 0;
document.getElementById('rotateImageBtn').onclick = ()=>{
  if(!img.naturalWidth) return;
  rotationAngle = (rotationAngle + 90) % 360;
  
  // Creo un canvas temporaneo per ruotare l'immagine
  const tempCanvas = document.createElement('canvas');
  const W = img.naturalWidth, H = img.naturalHeight;
  
  // Per rotazioni di 90 o 270 gradi, scambio larghezza e altezza
  if(rotationAngle === 90 || rotationAngle === 270){
    tempCanvas.width = H;
    tempCanvas.height = W;
  } else {
    tempCanvas.width = W;
    tempCanvas.height = H;
  }
  
  const ctx = tempCanvas.getContext('2d');
  ctx.translate(tempCanvas.width/2, tempCanvas.height/2);
  ctx.rotate(rotationAngle * Math.PI / 180);
  ctx.drawImage(img, -W/2, -H/2);
  
  // Aggiorno l'immagine con quella ruotata
  img.onload = ()=>{ drawModalAlpha(); };
  img.src = tempCanvas.toDataURL('image/png');
};

document.getElementById('applyFromModal').onclick = ()=>{
  // Chiudo subito la modale per vedere la mappa
  closePngModal();
  
  // Salvo l'immagine pulita
  lastAlphaDataURL = modalDst.toDataURL('image/png');
  pxSize = {w: modalDst.width, h: modalDst.height};
  
  // Creo o aggiorno l'overlay distorcibile sulla mappa Leaflet
  if(!overlay){
    placeOverlay();
  } else {
    refreshOverlay();
  }
  
  // Aggiorno anche l'immagine sorgente per i canvas dell'editor
  img.src = lastAlphaDataURL;
  
  log('Immagine pulita applicata sulla mappa.');
};

document.getElementById('downloadFromModal').onclick = ()=>{
  const a = document.createElement('a');
  a.href = modalDst.toDataURL('image/png');
  a.download = 'stalls_transparent.png';
  a.click();
};
</script>
</body>
</html>
