<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>DMS GIS ‚Äî Allineatore (ruota/scala/centra)</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root{--panel:#0f2330;--txt:#eaf1f5;--mut:#9fb1be;--acc:#1f8f5f}
  html,body,#map{height:100%;margin:0}
  #map{position:relative;z-index:1}
  
  .ui{
    position:fixed; top:12px; left:12px; z-index:10000;
    width:360px; max-width:min(92vw,420px); max-height:calc(100% - 24px);
    overflow:auto; background:var(--panel); color:var(--txt);
    padding:14px; border-radius:12px;
    box-shadow:0 10px 28px rgba(0,0,0,.35);
    font:14px system-ui;
  }
  .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .btn{background:var(--acc);border:0;color:#fff;padding:8px 10px;border-radius:8px;cursor:pointer}
  .btn.secondary{background:#2b3c48}
  .btn.danger{background:#b84040}
  .btn:disabled{opacity:0.5;cursor:not-allowed}
  .mut{color:var(--mut)} .small{font-size:12px}
  .group{border-top:1px solid #1a2d3a;margin-top:10px;padding-top:10px}
  
  input[type=range]{width:100%;margin:6px 0}
  label{display:block;margin-top:8px;font-size:13px}
  
  /* Stile overlay trascinabile */
  .leaflet-image-layer.draggable {
    cursor: move !important;
  }
</style>
</head>
<body>
<div id="map"></div>

<div class="ui">
  <h3 style="margin:0 0 6px">üéØ Allineatore</h3>
  <div class="small mut">Ruota, scala e centra l'immagine sulla mappa. NO distorsioni.</div>

  <div class="group">
    <b>1. Carica PNG dal Bus</b>
    <div class="row">
      <button class="btn secondary" id="loadFromBus">üì• Carica dal Bus</button>
    </div>
    <div class="small mut" id="loadStatus">In attesa...</div>
  </div>

  <div class="group">
    <b>2. Allinea Immagine</b>
    
    <label>Rotazione: <span id="rotVal">0</span>¬∞</label>
    <input type="range" id="rotation" min="0" max="360" value="0" step="1"/>
    
    <label>Scala: <span id="scaleVal">1.0</span>x</label>
    <input type="range" id="scale" min="0.1" max="5" value="1" step="0.1"/>
    
    <label>Opacit√†: <span id="opVal">1.00</span></label>
    <input type="range" id="opacity" min="0" max="1" value="1" step="0.05"/>
    
    <div class="row" style="margin-top:12px">
      <button class="btn secondary" id="resetTransform">‚Üª Reset</button>
      <button class="btn secondary" id="centerOnMap">üìç Centra su Mappa</button>
    </div>
    
    <div class="small mut" style="margin-top:8px">
      Trascina l'immagine per posizionarla. Usa gli slider per ruotare e scalare.
    </div>
  </div>

  <div class="group">
    <b>3. Salva GCP ed Esporta</b>
    <div class="row">
      <button class="btn" id="saveGCP" disabled>üíæ Salva GCP nel Bus</button>
      <button class="btn secondary" id="openContainerKit" disabled>‚û°Ô∏è Container Kit</button>
    </div>
    <div class="small mut" id="gcpStatus">Posiziona l'immagine prima di salvare.</div>
  </div>

  <div class="group">
    <b>Debug</b>
    <div class="small mut" id="debug">...</div>
  </div>
</div>

<script src="../shared/dms-bus.js"></script>
<script>
// Mappa
const map = L.map('map').setView([42.7633, 11.1117], 16);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 20,
  attribution: '¬© OSM'
}).addTo(map);

// Elementi UI
const loadStatus = document.getElementById('loadStatus');
const gcpStatus = document.getElementById('gcpStatus');
const debugEl = document.getElementById('debug');
const rotInput = document.getElementById('rotation');
const scaleInput = document.getElementById('scale');
const opInput = document.getElementById('opacity');
const rotVal = document.getElementById('rotVal');
const scaleVal = document.getElementById('scaleVal');
const opVal = document.getElementById('opVal');
const saveBtn = document.getElementById('saveGCP');
const openKitBtn = document.getElementById('openContainerKit');

// Stato
let imageOverlay = null;
let draggable = null;
let imageSize = {w: 0, h: 0};
let currentRotation = 0;
let currentScale = 1.0;
let currentOpacity = 1.0;
let centerLatLng = null; // Centro dell'immagine

// Funzioni di log
function log(msg) {
  debugEl.textContent = `[${new Date().toTimeString().slice(0,8)}] ${msg}`;
}

// 1. Carica PNG dal Bus
document.getElementById('loadFromBus').onclick = async () => {
  try {
    const blob = await DMSBUS.getBlob('png_transparent');
    const meta = await DMSBUS.getJSON('png_meta');
    
    if (!blob) {
      loadStatus.textContent = '‚ùå Nessun PNG nel bus. Usa prima "PNG Trasparente".';
      return;
    }
    
    imageSize = meta || {w: 1000, h: 800};
    loadStatus.textContent = `‚úÖ PNG caricato (${imageSize.w}x${imageSize.h})`;
    
    // Crea URL da Blob
    const url = URL.createObjectURL(blob);
    
    // Centro iniziale = centro mappa
    centerLatLng = map.getCenter();
    
    // Rimuovi overlay precedente
    if (imageOverlay) {
      map.removeLayer(imageOverlay);
      if (draggable) {
        draggable.disable();
      }
    }
    
    // Crea overlay
    const bounds = calculateBounds();
    imageOverlay = L.imageOverlay(url, bounds, {
      opacity: currentOpacity,
      interactive: true,
      className: 'draggable'
    }).addTo(map);
    
    // Abilita drag usando Leaflet.Draggable
    const element = imageOverlay.getElement();
    draggable = new L.Draggable(element);
    draggable.enable();
    
    // Eventi drag
    draggable.on('drag', function(e) {
      // Calcola nuovo centro in base al movimento del mouse
      const containerPoint = map.latLngToContainerPoint(centerLatLng);
      const newContainerPoint = L.point(
        containerPoint.x + draggable._newPos.x - draggable._startPoint.x,
        containerPoint.y + draggable._newPos.y - draggable._startPoint.y
      );
      centerLatLng = map.containerPointToLatLng(newContainerPoint);
    });
    
    draggable.on('dragend', function() {
      // Resetta posizione CSS e aggiorna bounds
      element.style.transform = `translate(0px, 0px) rotate(${currentRotation}deg)`;
      element.style.transformOrigin = 'center';
      const newBounds = calculateBounds();
      imageOverlay.setBounds(newBounds);
      draggable._startPoint = {x: 0, y: 0};
      draggable._newPos = {x: 0, y: 0};
      log('Centrato su mappa');
    });
    
    log('Immagine caricata. Trascina per posizionare.');
    saveBtn.disabled = false;
    openKitBtn.disabled = false;
    gcpStatus.textContent = 'Immagine pronta. Allinea e salva GCP.';
    
  } catch (err) {
    loadStatus.textContent = `‚ùå Errore: ${err.message}`;
    log(`Errore caricamento: ${err}`);
  }
};

// Calcola bounds in base a centro, scala e dimensioni immagine
function calculateBounds() {
  if (!centerLatLng) return [[0,0],[0,0]];
  
  const zoom = map.getZoom();
  const metersPerPixel = 156543.03392 * Math.cos(centerLatLng.lat * Math.PI / 180) / Math.pow(2, zoom);
  const widthMeters = imageSize.w * metersPerPixel * currentScale * 0.3; // 0.3 = fattore scala iniziale
  const heightMeters = imageSize.h * metersPerPixel * currentScale * 0.3;
  
  const latOffset = (heightMeters / 111320) / 2;
  const lngOffset = (widthMeters / (111320 * Math.cos(centerLatLng.lat * Math.PI / 180))) / 2;
  
  return [
    [centerLatLng.lat - latOffset, centerLatLng.lng - lngOffset], // SW
    [centerLatLng.lat + latOffset, centerLatLng.lng + lngOffset]  // NE
  ];
}

// 2. Controlli trasformazione
rotInput.oninput = () => {
  currentRotation = parseFloat(rotInput.value);
  rotVal.textContent = currentRotation;
  updateTransform();
};

scaleInput.oninput = () => {
  currentScale = parseFloat(scaleInput.value);
  scaleVal.textContent = currentScale.toFixed(1);
  updateTransform();
};

opInput.oninput = () => {
  currentOpacity = parseFloat(opInput.value);
  opVal.textContent = currentOpacity.toFixed(2);
  if (imageOverlay) {
    imageOverlay.setOpacity(currentOpacity);
  }
};

function updateTransform() {
  if (!imageOverlay || !centerLatLng) return;
  
  // Aggiorna bounds con nuova scala
  const newBounds = calculateBounds();
  imageOverlay.setBounds(newBounds);
  
  // Applica rotazione (CSS transform)
  const el = imageOverlay.getElement();
  if (el) {
    el.style.transform = `rotate(${currentRotation}deg)`;
    el.style.transformOrigin = 'center';
  }
  
  log(`Trasformato: rot=${currentRotation}¬∞ scala=${currentScale}x`);
}

document.getElementById('resetTransform').onclick = () => {
  rotInput.value = 0;
  scaleInput.value = 1;
  opInput.value = 1;
  currentRotation = 0;
  currentScale = 1.0;
  currentOpacity = 1.0;
  rotVal.textContent = '0';
  scaleVal.textContent = '1.0';
  opVal.textContent = '1.00';
  updateTransform();
  log('Reset trasformazioni');
};

document.getElementById('centerOnMap').onclick = () => {
  if (imageOverlay) {
    map.fitBounds(imageOverlay.getBounds());
    log('Centrato su mappa');
  }
};

// 3. Salva GCP
document.getElementById('saveGCP').onclick = async () => {
  if (!imageOverlay) {
    alert('Nessuna immagine caricata!');
    return;
  }
  
  try {
    const bounds = imageOverlay.getBounds();
    const sw = bounds.getSouthWest();
    const ne = bounds.getNorthEast();
    const nw = L.latLng(ne.lat, sw.lng);
    const se = L.latLng(sw.lat, ne.lng);
    
    // GCP: 4 angoli (NW, NE, SW, SE) con coordinate pixel e geografiche
    const gcp = {
      corners: [
        {px: [0, 0], ll: [nw.lat, nw.lng]},                    // NW
        {px: [imageSize.w, 0], ll: [ne.lat, ne.lng]},          // NE
        {px: [0, imageSize.h], ll: [sw.lat, sw.lng]},          // SW
        {px: [imageSize.w, imageSize.h], ll: [se.lat, se.lng]} // SE
      ],
      imageW: imageSize.w,
      imageH: imageSize.h,
      rotation: currentRotation,
      scale: currentScale
    };
    
    await DMSBUS.putJSON('gcp', gcp);
    gcpStatus.textContent = '‚úÖ GCP salvati nel bus!';
    log('GCP salvati');
    alert('‚úÖ GCP salvati nel bus!');
    
  } catch (err) {
    alert('‚ùå Errore: ' + err.message);
    log('Errore salvataggio GCP: ' + err);
  }
};

document.getElementById('openContainerKit').onclick = () => {
  window.open('container_kit.html', '_blank');
};
</script>
</body>
</html>

