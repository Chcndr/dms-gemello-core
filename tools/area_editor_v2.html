<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DMS ‚Ä¢ AREA EDITOR v2 ‚Äî Disegna Mercati e Hub</title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; }
    
    .topbar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      background: #0f2830;
      color: #d5f0e6;
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 2000;
      height: 48px;
    }
    .brand { font-weight: 600; font-size: 16px; }
    .ver { font-size: 12px; opacity: 0.7; }
    
    #map { position: absolute; top: 48px; left: 0; width: 100%; height: calc(100% - 48px); z-index: 0; }
    
    #sidebar {
      position: absolute;
      top: 48px;
      left: 0;
      width: 340px;
      height: calc(100vh - 48px);
      background: linear-gradient(180deg, rgba(20, 30, 40, 0.98) 0%, rgba(30, 40, 50, 0.98) 100%);
      color: white;
      box-shadow: 4px 0 24px rgba(0,0,0,0.5);
      overflow-y: auto;
      z-index: 1000;
      padding: 0;
      display: flex;
      flex-direction: column;
    }
    
    #sidebar-header {
      padding: 20px;
      background: rgba(0,0,0,0.2);
      border-bottom: 2px solid rgba(33, 150, 243, 0.3);
      flex-shrink: 0;
    }
    
    #sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    
    #sidebar-footer {
      padding: 15px 20px;
      background: rgba(0,0,0,0.3);
      border-top: 1px solid rgba(255,255,255,0.1);
      flex-shrink: 0;
    }
    
    #preview-container {
      margin-top: 10px;
      border: 2px solid rgba(33, 150, 243, 0.5);
      border-radius: 8px;
      overflow: hidden;
      background: rgba(0,0,0,0.3);
    }
    
    #preview-label {
      padding: 8px;
      background: rgba(33, 150, 243, 0.2);
      font-size: 12px;
      font-weight: 600;
      text-align: center;
      border-bottom: 1px solid rgba(33, 150, 243, 0.3);
    }
    
    #preview-map {
      width: 100%;
      height: 180px;
      background: #1e2838;
    }
    
    h2 { font-size: 18px; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    h3 { font-size: 15px; margin-top: 20px; margin-bottom: 8px; }
    p { font-size: 13px; opacity: 0.8; margin-bottom: 12px; line-height: 1.4; }
    
    button {
      width: 100%;
      padding: 12px;
      margin-bottom: 8px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button:hover:not(:disabled) { background: #1976D2; transform: translateY(-1px); }
    button:disabled { background: #555; cursor: not-allowed; opacity: 0.5; }
    
    .slider-group {
      margin-bottom: 16px;
      padding: 12px;
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 13px;
    }
    
    .slider-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .slider-controls button {
      width: 40px;
      padding: 8px;
      margin: 0;
    }
    
    input[type="range"] {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.2);
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #2196F3;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #2196F3;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .status {
      margin-top: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 6px;
      font-size: 12px;
    }
    
    /* Overlay pixel */
    #pixel-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 400;
    }
    
    #pixel-image {
      position: absolute;
      cursor: move;
      pointer-events: auto;
    }
    
    #pixel-rect {
      position: absolute;
      border: 3px solid #f44336;
      pointer-events: none;
    }
    
    .corner-marker {
      position: absolute;
      width: 28px;
      height: 28px;
      background: #f44336;
      color: white;
      border: 3px solid white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      pointer-events: none;
      transform: translate(-50%, -50%);
    }
    
    #center-marker {
      position: absolute;
      width: 24px;
      height: 24px;
      background: #f44336;
      border: 3px solid white;
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      cursor: move;
      pointer-events: auto;
      transform: translate(-50%, -50%);
      z-index: 500;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="brand">DMS ‚Ä¢ GEMELLO DIGITALE ‚Äî Area Editor v2</div>
    <div class="ver">v2.0 pixel-based</div>
  </header>
  <div id="map"></div>
  
  <div id="sidebar">
    <div id="sidebar-header">
      <h2>üó∫Ô∏è Area Editor v2</h2>
      <p style="font-size: 11px; opacity: 0.6; margin: 0;">Versione pixel-based</p>
      <div style="margin-top: 10px;">
        <a href="bus_hub.html" style="display: inline-block; background: #1a9e9e; color: white; padding: 8px 12px; border-radius: 4px; text-decoration: none; font-size: 12px; font-weight: 600;">
          üöå BUS HUB
        </a>
      </div>
    </div>
    
    <div id="sidebar-content">
    
    <!-- STEP 1: Blocca Mappa -->
    <h3>1Ô∏è‚É£ Blocca Mappa</h3>
    <p>Posiziona e zumma la mappa, poi bloccala.</p>
    <button onclick="toggleMapLock()" id="btnLock">üîì Blocca Mappa</button>
    
    <!-- STEP 2: Allinea Pianta -->
    <h3>2Ô∏è‚É£ Allinea Pianta</h3>
    <p>Mostra, trascina, ruota e scala la pianta.</p>
    <button onclick="showOverlay()" id="btnShow" disabled>üìç Mostra Pianta</button>
    
    <div id="controls" style="display: none;">
      <!-- Rotazione -->
      <div class="slider-group">
        <div class="slider-label">
          <span>üîÑ Rotazione</span>
          <span id="rotationValue">0¬∞</span>
        </div>
        <div class="slider-controls">
          <button onclick="adjustRotation(-0.5)">‚àí</button>
          <input type="range" id="rotationSlider" min="0" max="360" step="0.5" value="0" 
                 oninput="updateRotation(this.value)">
          <button onclick="adjustRotation(0.5)">+</button>
        </div>
      </div>
      
      <!-- Scala -->
      <div class="slider-group">
        <div class="slider-label">
          <span>üìè Scala</span>
          <span id="scaleValue">1.0x</span>
        </div>
        <div class="slider-controls">
          <button onclick="adjustScale(-0.01)">‚àí</button>
          <input type="range" id="scaleSlider" min="0.1" max="3" step="0.01" value="1.0" 
                 oninput="updateScale(this.value)">
          <button onclick="adjustScale(0.01)">+</button>
        </div>
      </div>
      
      <!-- Opacit√† -->
      <div class="slider-group">
        <div class="slider-label">
          <span>‚òÄÔ∏è Opacit√†</span>
          <span id="opacityValue">0.7</span>
        </div>
        <div class="slider-controls">
          <button onclick="adjustOpacity(-0.1)">‚àí</button>
          <input type="range" id="opacitySlider" min="0.1" max="1" step="0.05" value="0.7" 
                 oninput="updateOpacity(this.value)">
          <button onclick="adjustOpacity(0.1)">+</button>
        </div>
      </div>
      
      <button onclick="resetTransform()">üîÑ Reset Trasformazioni</button>
    </d      <button onclick="fixOverlay()" id="btnFix" disabled>‚úÖ Fissa Pianta</button>
      <button onclick="goToSlotEditor()" style="background: #4caf50; margin-top: 10px;">‚û°Ô∏è Vai a Slot Editor (Test)</button>
      
      <div id="alignStatus" class="status">‚ö†Ô∏è Carica PNG dal PNG Trasparente tool</div>
    
    <!-- STEP 3: Disegna Area -->
    <h3>3Ô∏è‚É£ Disegna Area</h3>
    <p>Disegna poligono libero sulla mappa.</p>
    
    <button onclick="startDrawArea('mercato')" id="btnDrawMercato" disabled>üè™ Disegna Area Mercato</button>
    <button onclick="startDrawArea('hub')" id="btnDrawHub" disabled>üè¢ Disegna Area HUB</button>
    
    <div id="drawStatus" class="status" style="display: none;">Click sulla mappa per iniziare</div>
    
    <!-- STEP 4: Salva -->
    <h3>4Ô∏è‚É£ Salva</h3>
    <p>Salva area nel bus e vai a Slot Editor.</p>
    
    <button onclick="saveArea()" id="btnSave" disabled>üíæ Salva Area nel Bus</button>    <button onclick="goToSlotEditor()" id="btnNext" disabled">‚û°Ô∏è Vai a Slot Editor</button>
    
    <div id="saveStatus" class="status" style="display: none;">Pronto per salvare</div>
    
    <!-- STEP 5: Pulisci -->
    <h3>5Ô∏è‚É£ Pulisci</h3>
    <p>Rimuovi pianta e svuota bus per ricominciare.</p>
    <button onclick="cleanAll()" style="background: #f44336;">üßπ Pulisci Tutto</button>
    
    </div><!-- fine sidebar-content -->
    
    <div id="sidebar-footer">
      <div id="preview-container">
        <div id="preview-label">üó∫Ô∏è Preview Mappa Salvata</div>
        <div id="preview-map"></div>
      </div>
    </div>
  </div><!-- fine sidebar -->
  
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="../shared/dms-bus.js"></script>
  
  <script>
    // Inizializza mappa
    const map = L.map('map', {
      center: [42.758, 11.114],
      zoom: 16,
      zoomControl: false,
      zoomDelta: 0.25,  // Step zoom ridotto (default 1)
      zoomSnap: 0.25    // Snap zoom ridotto (default 1)
    });
    
    L.control.zoom({ position: 'topright' }).addTo(map);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap',
      maxZoom: 19
    }).addTo(map);
    
    // Stato
    let mapLocked = false;
    let pngBlob = null;
    let pngMeta = null;
    let imageUrl = null;
    
    let overlayDiv = null;
    let imageElement = null;
    let rectElement = null;
    let cornerMarkers = [];
    
    let currentRotation = 0;
    let currentScale = 1.0;
    let currentOpacity = 0.7;
    let currentX = 0;
    let currentY = 0;
    
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragStartImgX = 0;
    let dragStartImgY = 0;
    
    // Stato disegno area
    let drawControl = null;
    let drawnItems = null;
    let currentAreaType = null; // 'mercato' o 'hub'
    let areaLayer = null;
    let areaGeoJSON = null;
    
    // Carica PNG dal bus
    async function loadPNGFromBus() {
      try {
        pngBlob = await DMSBUS.getBlob('png_transparent');
        pngMeta = await DMSBUS.getJSON('png_meta');
        
        if (pngBlob && pngMeta) {
          imageUrl = URL.createObjectURL(pngBlob);
          document.getElementById('alignStatus').innerHTML = 
            `‚úÖ PNG caricato (${pngMeta.w}x${pngMeta.h}px)<br>Blocca la mappa per iniziare`;
        } else {
          document.getElementById('alignStatus').textContent = 
            '‚ö†Ô∏è Nessun PNG nel bus. Completa prima PNG Trasparente.';
        }
      } catch (err) {
        console.error('Errore caricamento PNG:', err);
      }
    }
    
    // Blocca/sblocca mappa
    function toggleMapLock() {
      mapLocked = !mapLocked;
      
      if (mapLocked) {
        map.dragging.disable();
        map.touchZoom.disable();
        map.doubleClickZoom.disable();
        map.scrollWheelZoom.disable();
        map.boxZoom.disable();
        map.keyboard.disable();
        if (map.tap) map.tap.disable();
        
        document.getElementById('btnLock').innerHTML = 'üîí Sblocca Mappa';
        document.getElementById('btnLock').style.background = '#4CAF50';
        document.getElementById('btnShow').disabled = false;
        document.getElementById('alignStatus').innerHTML = 
          '<strong style="color: #4CAF50">üîí Mappa bloccata! Clicca "Mostra Pianta"</strong>';
      } else {
        map.dragging.enable();
        map.touchZoom.enable();
        map.doubleClickZoom.enable();
        map.scrollWheelZoom.enable();
        map.boxZoom.enable();
        map.keyboard.enable();
        if (map.tap) map.tap.enable();
        
        document.getElementById('btnLock').innerHTML = 'üîì Blocca Mappa';
        document.getElementById('btnLock').style.background = '';
        document.getElementById('btnShow').disabled = true;
        document.getElementById('alignStatus').innerHTML = 
          pngBlob ? `‚úÖ PNG caricato (${pngMeta.w}x${pngMeta.h}px)<br>Blocca la mappa per iniziare` : 
          'Carica PNG dal PNG Trasparente tool';
      }
    }
    
    // Mostra overlay in pixel
    function showOverlay() {
      if (!imageUrl || !mapLocked) {
        alert('‚ùå Blocca prima la mappa!');
        return;
      }
      
      const mapContainer = map.getContainer();
      const mapSize = map.getSize();
      
      // Crea container overlay
      overlayDiv = document.createElement('div');
      overlayDiv.id = 'pixel-overlay';
      mapContainer.appendChild(overlayDiv);
      
      // Calcola dimensioni iniziali
      const maxSize = Math.min(mapSize.x, mapSize.y) * 0.6;
      const aspectRatio = pngMeta.w / pngMeta.h;
      let imgWidth, imgHeight;
      if (aspectRatio > 1) {
        imgWidth = maxSize;
        imgHeight = maxSize / aspectRatio;
      } else {
        imgHeight = maxSize;
        imgWidth = maxSize * aspectRatio;
      }
      
      // Posizione iniziale (centro)
      currentX = mapSize.x / 2;
      currentY = mapSize.y / 2;
      
      // Crea immagine
      imageElement = document.createElement('img');
      imageElement.id = 'pixel-image';
      imageElement.src = imageUrl;
      imageElement.style.width = imgWidth + 'px';
      imageElement.style.height = imgHeight + 'px';
      imageElement.style.opacity = currentOpacity;
      overlayDiv.appendChild(imageElement);
      
      // Crea rettangolo
      rectElement = document.createElement('div');
      rectElement.id = 'pixel-rect';
      overlayDiv.appendChild(rectElement);
      
      // Crea punto rosso centrale
      const centerMarker = document.createElement('div');
      centerMarker.id = 'center-marker';
      overlayDiv.appendChild(centerMarker);
      
      // Eventi drag per punto centrale
      centerMarker.addEventListener('mousedown', startCenterDrag);
      centerMarker.addEventListener('touchstart', startCenterDrag);
      
      // Crea marker angoli
      for (let i = 1; i <= 4; i++) {
        const marker = document.createElement('div');
        marker.className = 'corner-marker';
        marker.textContent = i;
        overlayDiv.appendChild(marker);
        cornerMarkers.push(marker);
      }
      
      // Eventi drag
      imageElement.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', endDrag);
      
      // Touch events
      imageElement.addEventListener('touchstart', startDrag);
      document.addEventListener('touchmove', drag);
      document.addEventListener('touchend', endDrag);
      
      // Applica trasformazione iniziale
      applyTransform();
      
      // Abilita controlli
      document.getElementById('controls').style.display = 'block';
      document.getElementById('btnFix').disabled = false;
      document.getElementById('alignStatus').innerHTML = 
        '<strong style="color: #4CAF50">‚úÖ Trascina, ruota e scala!</strong>';
      
      console.log('‚úÖ Overlay pixel mostrato');
    }
    
    // Drag handlers per immagine
    function startDrag(e) {
      isDragging = true;
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);
      dragStartX = clientX;
      dragStartY = clientY;
      dragStartImgX = currentX;
      dragStartImgY = currentY;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Drag handlers per punto centrale
    function startCenterDrag(e) {
      isDragging = true;
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);
      dragStartX = clientX;
      dragStartY = clientY;
      dragStartImgX = currentX;
      dragStartImgY = currentY;
      e.preventDefault();
      e.stopPropagation();
    }
    
    function drag(e) {
      if (!isDragging) return;
      const clientX = e.clientX || (e.touches && e.touches[0].clientX);
      const clientY = e.clientY || (e.touches && e.touches[0].clientY);
      const dx = clientX - dragStartX;
      const dy = clientY - dragStartY;
      currentX = dragStartImgX + dx;
      currentY = dragStartImgY + dy;
      applyTransform();
      e.preventDefault();
    }
    
    function endDrag() {
      isDragging = false;
    }
    
    // Trasformazioni
    function updateRotation(value) {
      currentRotation = parseFloat(value);
      document.getElementById('rotationValue').textContent = Math.round(currentRotation) + '¬∞';
      applyTransform();
    }
    
    function adjustRotation(delta) {
      const newValue = Math.max(0, Math.min(360, currentRotation + delta));
      document.getElementById('rotationSlider').value = newValue;
      updateRotation(newValue);
    }
    
    function updateScale(value) {
      currentScale = parseFloat(value);
      document.getElementById('scaleValue').textContent = currentScale.toFixed(1) + 'x';
      applyTransform();
    }
    
    function adjustScale(delta) {
      const newValue = Math.max(0.1, Math.min(3, currentScale + delta));
      document.getElementById('scaleSlider').value = newValue;
      updateScale(newValue);
    }
    
    function updateOpacity(value) {
      currentOpacity = parseFloat(value);
      document.getElementById('opacityValue').textContent = currentOpacity.toFixed(2);
      if (imageElement) {
        imageElement.style.opacity = currentOpacity;
      }
    }
    
    function adjustOpacity(delta) {
      const newValue = Math.max(0.1, Math.min(1, currentOpacity + delta));
      document.getElementById('opacitySlider').value = newValue;
      updateOpacity(newValue);
    }
    
    function resetTransform() {
      currentRotation = 0;
      currentScale = 1.0;
      currentOpacity = 0.7;
      document.getElementById('rotationSlider').value = 0;
      document.getElementById('scaleSlider').value = 1.0;
      document.getElementById('opacitySlider').value = 0.7;
      document.getElementById('rotationValue').textContent = '0¬∞';
      document.getElementById('scaleValue').textContent = '1.0x';
      document.getElementById('opacityValue').textContent = '0.70';
      applyTransform();
    }
    
    // Applica trasformazione
    function applyTransform() {
      if (!imageElement || !rectElement) return;
      
      const imgWidth = parseFloat(imageElement.style.width);
      const imgHeight = parseFloat(imageElement.style.height);
      
      const scaledWidth = imgWidth * currentScale;
      const scaledHeight = imgHeight * currentScale;
      
      // Applica transform all'immagine
      imageElement.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg) scale(${currentScale})`;
      imageElement.style.left = currentX + 'px';
      imageElement.style.top = currentY + 'px';
      
      // Applica transform al rettangolo
      rectElement.style.width = scaledWidth + 'px';
      rectElement.style.height = scaledHeight + 'px';
      rectElement.style.left = (currentX - scaledWidth / 2) + 'px';
      rectElement.style.top = (currentY - scaledHeight / 2) + 'px';
      rectElement.style.transform = `rotate(${currentRotation}deg)`;
      rectElement.style.transformOrigin = 'center';
      
      // Aggiorna marker angoli (ruotati)
      const halfW = scaledWidth / 2;
      const halfH = scaledHeight / 2;
      const rad = (currentRotation * Math.PI) / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      
      const corners = [
        { x: -halfW, y: -halfH }, // NW
        { x: halfW, y: -halfH },  // NE
        { x: halfW, y: halfH },   // SE
        { x: -halfW, y: halfH }   // SW
      ];
      
      corners.forEach((corner, i) => {
        const rotX = corner.x * cos - corner.y * sin;
        const rotY = corner.x * sin + corner.y * cos;
        cornerMarkers[i].style.left = (currentX + rotX) + 'px';
        cornerMarkers[i].style.top = (currentY + rotY) + 'px';
      });
      
      // Aggiorna punto centrale
      const centerMarker = document.getElementById('center-marker');
      if (centerMarker) {
        centerMarker.style.left = currentX + 'px';
        centerMarker.style.top = currentY + 'px';
      }
    }
    
    // Ruota immagine con canvas
    function rotateImage(imageUrl, rotation) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Calcola dimensioni canvas ruotato
          const rad = (rotation * Math.PI) / 180;
          const cos = Math.abs(Math.cos(rad));
          const sin = Math.abs(Math.sin(rad));
          const newWidth = img.width * cos + img.height * sin;
          const newHeight = img.width * sin + img.height * cos;
          
          canvas.width = newWidth;
          canvas.height = newHeight;
          
          // Ruota e disegna
          ctx.translate(newWidth / 2, newHeight / 2);
          ctx.rotate(rad);
          ctx.drawImage(img, -img.width / 2, -img.height / 2);
          
          // Converti in blob
          canvas.toBlob((blob) => {
            resolve(URL.createObjectURL(blob));
          }, 'image/png');
        };
        img.src = imageUrl;
      });
    }
    
    // Fissa pianta (converti pixel ‚Üí coordinate geografiche)
    async function fixOverlay() {
      if (!imageElement) return;
      
      const imgWidth = parseFloat(imageElement.style.width) * currentScale;
      const imgHeight = parseFloat(imageElement.style.height) * currentScale;
      const rad = (currentRotation * Math.PI) / 180;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      
      // Calcola dimensioni dopo rotazione (cambiano!)
      const rotatedWidth = Math.abs(imgWidth * Math.cos(rad)) + Math.abs(imgHeight * Math.sin(rad));
      const rotatedHeight = Math.abs(imgWidth * Math.sin(rad)) + Math.abs(imgHeight * Math.cos(rad));
      const halfW = rotatedWidth / 2;
      const halfH = rotatedHeight / 2;
      
      // Calcola angoli in pixel
      const corners = [
        { x: -halfW, y: -halfH }, // NW
        { x: halfW, y: -halfH },  // NE
        { x: halfW, y: halfH },   // SE
        { x: -halfW, y: halfH }   // SW
      ];
      
      // Converti pixel ‚Üí coordinate geografiche
      const gcp = {
        corners: {},
        image: { width: pngMeta.w, height: pngMeta.h },
        rotation: currentRotation,
        scale: currentScale,
        timestamp: new Date().toISOString()
      };
      
      ['nw', 'ne', 'se', 'sw'].forEach((name, i) => {
        // Non ruotare i corners perch√© l'immagine sar√† gi√† ruotata dal canvas
        const pixelX = currentX + corners[i].x;
        const pixelY = currentY + corners[i].y;
        const latlng = map.containerPointToLatLng([pixelX, pixelY]);
        gcp.corners[name] = [latlng.lat, latlng.lng];
      });
      
      // Crea container per Slot Editor
      const container = {
        id: 'mercato_' + Date.now(),
        name: 'Mercato',
        type: 'mercato',
        timestamp: gcp.timestamp,
        image: gcp.image,
        gcp: [
          { px: [0, 0], ll: gcp.corners.nw, note: 'NW' },
          { px: [gcp.image.width, 0], ll: gcp.corners.ne, note: 'NE' },
          { px: [gcp.image.width, gcp.image.height], ll: gcp.corners.se, note: 'SE' },
          { px: [0, gcp.image.height], ll: gcp.corners.sw, note: 'SW' }
        ],
        area_px: [[0, 0], [gcp.image.width, 0], [gcp.image.width, gcp.image.height], [0, gcp.image.height]],
        stalls_px: []
      };
      
      // Salva nel bus
      try {
        await DMSBUS.putJSON('gcp', gcp);
        await DMSBUS.putJSON('container', container);
        
        // Rimuovi overlay pixel
        if (overlayDiv) {
          overlayDiv.remove();
          overlayDiv = null;
          imageElement = null;
          rectElement = null;
          cornerMarkers = [];
        }
        
        // Se c'√® rotazione, ruota l'immagine prima
        let finalImageUrl = imageUrl;
        if (currentRotation !== 0) {
          finalImageUrl = await rotateImage(imageUrl, currentRotation);
          console.log('üîÑ Immagine ruotata:', currentRotation + '¬∞');
        }
        
        // Crea overlay geografico (L.imageOverlay) con i GCP
        // Usa bounds del rettangolo (senza rotazione, perch√© immagine √® gi√† ruotata)
        const geoBounds = [
          [gcp.corners.nw[0], gcp.corners.nw[1]],
          [gcp.corners.se[0], gcp.corners.se[1]]
        ];
        
        const geoOverlay = L.imageOverlay(finalImageUrl, geoBounds, {
          opacity: currentOpacity,
          interactive: false
        }).addTo(map);
        
        console.log('‚úÖ Overlay geografico creato:', geoBounds);
        
        // Sblocca mappa
        mapLocked = false;
        toggleMapLock(); // Chiama per aggiornare UI
        
        document.getElementById('controls').style.display = 'none';
        document.getElementById('btnFix').disabled = true;
        document.getElementById('alignStatus').innerHTML = 
          '<strong style="color: #4CAF50">‚úÖ Pianta fissata! GCP salvati nel bus.</strong>';
        
        alert('‚úÖ Pianta fissata! Ora puoi disegnare l\'area mercato.');
        console.log('‚úÖ GCP salvati:', gcp);
        
        // Abilita pulsanti disegno
        document.getElementById('btnDrawMercato').disabled = false;
        document.getElementById('btnDrawHub').disabled = false;
        
        // Aggiorna preview
        setTimeout(() => updatePreview(), 500);
      } catch (err) {
        alert('‚ùå Errore salvataggio GCP: ' + err.message);
      }
    }
    
    // Inizializza Leaflet.draw
    function initDraw() {
      drawnItems = new L.FeatureGroup();
      map.addLayer(drawnItems);
      
      drawControl = new L.Control.Draw({
        draw: {
          polygon: {
            allowIntersection: false,
            showArea: true,
            drawError: {
              color: '#e1e100',
              message: '<strong>Errore:</strong> il poligono non pu√≤ intersecarsi!'
            },
            shapeOptions: {
              color: '#f44336',
              weight: 3,
              opacity: 0.8,
              fillOpacity: 0.3
            }
          },
          polyline: false,
          rectangle: false,
          circle: false,
          marker: false,
          circlemarker: false
        },
        edit: {
          featureGroup: drawnItems,
          remove: true
        }
      });
      
      // Eventi disegno
      map.on(L.Draw.Event.CREATED, function(e) {
        const layer = e.layer;
        
        // Rimuovi layer precedente se esiste
        if (areaLayer) {
          drawnItems.removeLayer(areaLayer);
        }
        
        areaLayer = layer;
        drawnItems.addLayer(layer);
        
        // Crea GeoJSON
        const geojson = layer.toGeoJSON();
        geojson.properties = {
          type: currentAreaType,
          name: currentAreaType === 'mercato' ? 'Mercato Esperanto' : 'HUB Esperanto',
          description: '',
          timestamp: new Date().toISOString()
        };
        
        areaGeoJSON = geojson;
        
        // Abilita salvataggio
        document.getElementById('btnSave').disabled = false;
        document.getElementById('drawStatus').style.display = 'block';
        document.getElementById('drawStatus').innerHTML = 
          '<strong style="color: #4CAF50">‚úÖ Area disegnata! Clicca Salva.</strong>';
        
        console.log('‚úÖ Area disegnata:', geojson);
      });
      
      map.on(L.Draw.Event.DELETED, function() {
        areaLayer = null;
        areaGeoJSON = null;
        document.getElementById('btnSave').disabled = true;
        document.getElementById('drawStatus').innerHTML = 'Click sulla mappa per iniziare';
      });
    }
    
    // Inizia disegno area
    function startDrawArea(type) {
      currentAreaType = type;
      
      // Inizializza draw se non gi√† fatto
      if (!drawControl) {
        initDraw();
      }
      
      // Aggiungi controllo draw alla mappa
      if (!map.hasLayer(drawControl)) {
        map.addControl(drawControl);
      }
      
      document.getElementById('drawStatus').style.display = 'block';
      document.getElementById('drawStatus').innerHTML = 
        `<strong>Disegna ${type === 'mercato' ? 'Area Mercato' : 'Area HUB'}</strong><br>` +
        'Click sulla mappa per iniziare. Doppio click per chiudere.';
      
      // Attiva automaticamente il tool poligono
      new L.Draw.Polygon(map, drawControl.options.draw.polygon).enable();
    }
    
    // Salva area nel bus
    async function saveArea() {
      if (!areaGeoJSON) {
        alert('‚ùå Disegna prima un\'area!');
        return;
      }
      
      try {
        await DMSBUS.putJSON('area_geojson', areaGeoJSON);
        
        document.getElementById('saveStatus').style.display = 'block';
        document.getElementById('saveStatus').innerHTML = 
          '<strong style="color: #4CAF50">‚úÖ Area salvata nel bus!</strong>';
        
        document.getElementById('btnNext').disabled = false;
        
        alert('‚úÖ Area salvata! Vai a Slot Editor per aggiungere i posteggi.');
        console.log('‚úÖ Area salvata nel bus:', areaGeoJSON);
      } catch (err) {
        alert('‚ùå Errore salvataggio area: ' + err.message);
      }
    }
    
    // Vai a Slot Editor
    function goToSlotEditor() {
      window.location.href = 'slot_editor.html';
    }
    
    // Pulisci tutto
    async function cleanAll() {
      if (!confirm('‚ö†Ô∏è Vuoi davvero pulire tutto? Questo rimuover√†:\n\n- Pianta dalla mappa\n- Pianta dalla preview\n- GCP dal bus\n- Area dal bus\n\nQuesta azione non pu√≤ essere annullata!')) {
        return;
      }
      
      try {
        // Rimuovi overlay dalla mappa principale
        map.eachLayer((layer) => {
          if (layer instanceof L.ImageOverlay) {
            map.removeLayer(layer);
          }
        });
        
        // Rimuovi overlay pixel se esiste
        if (overlayDiv) {
          overlayDiv.remove();
          overlayDiv = null;
          imageElement = null;
          rectElement = null;
          cornerMarkers = [];
        }
        
        // Rimuovi area disegnata
        if (drawnItems) {
          drawnItems.clearLayers();
        }
        areaLayer = null;
        areaGeoJSON = null;
        
        // Rimuovi preview
        if (previewOverlay) {
          previewMap.removeLayer(previewOverlay);
          previewOverlay = null;
        }
        document.getElementById('preview-label').innerHTML = '‚ö†Ô∏è Nessuna pianta salvata';
        
        // Svuota bus
        await DMSBUS.deleteKey('gcp');
        await DMSBUS.deleteKey('area_geojson');
        
        // Reset UI
        document.getElementById('btnShow').disabled = false;
        document.getElementById('btnFix').disabled = true;
        document.getElementById('btnDrawMercato').disabled = true;
        document.getElementById('btnDrawHub').disabled = true;
        document.getElementById('btnSave').disabled = true;
        document.getElementById('btnNext').disabled = true;
        document.getElementById('controls').style.display = 'none';
        document.getElementById('alignStatus').innerHTML = 'Carica PNG dal PNG Trasparente tool';
        document.getElementById('drawStatus').style.display = 'none';
        document.getElementById('saveStatus').style.display = 'none';
        
        // Reset valori
        currentRotation = 0;
        currentScale = 1.0;
        currentOpacity = 0.7;
        currentX = 0;
        currentY = 0;
        
        alert('‚úÖ Tutto pulito! Puoi ricominciare da zero.');
        console.log('üßπ Tutto pulito');
      } catch (err) {
        alert('‚ùå Errore pulizia: ' + err.message);
      }
    }
    
    // Inizializza preview map
    let previewMap = null;
    let previewOverlay = null;
    
    function initPreviewMap() {
      if (previewMap) return;
      
      previewMap = L.map('preview-map', {
        center: [42.758, 11.114],
        zoom: 14,
        zoomControl: false,
        dragging: false,
        touchZoom: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        boxZoom: false,
        keyboard: false,
        tap: false
      });
      
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '',
        maxZoom: 19
      }).addTo(previewMap);
    }
    
    async function updatePreview() {
      if (!previewMap) {
        initPreviewMap();
      }
      
      try {
        const gcp = await DMSBUS.getJSON('gcp');
        const pngBlob = await DMSBUS.getBlob('png_transparent');
        
        if (gcp && pngBlob) {
          let imageUrl = URL.createObjectURL(pngBlob);
          
          // Se c'√® rotazione, ruota l'immagine
          if (gcp.rotation && gcp.rotation !== 0) {
            imageUrl = await rotateImage(imageUrl, gcp.rotation);
          }
          
          const bounds = [
            gcp.corners.nw,
            gcp.corners.ne,
            gcp.corners.se,
            gcp.corners.sw
          ];
          
          // Rimuovi overlay precedente
          if (previewOverlay) {
            previewMap.removeLayer(previewOverlay);
          }
          
          // Crea nuovo overlay
          previewOverlay = L.imageOverlay(imageUrl, [
            [bounds[0][0], bounds[0][1]],
            [bounds[2][0], bounds[2][1]]
          ], {
            opacity: 0.7,
            interactive: false
          }).addTo(previewMap);
          
          // Fit bounds
          previewMap.fitBounds([
            [bounds[0][0], bounds[0][1]],
            [bounds[2][0], bounds[2][1]]
          ]);
          
          document.getElementById('preview-label').innerHTML = '‚úÖ Pianta Georeferenziata';
        } else {
          document.getElementById('preview-label').innerHTML = '‚ö†Ô∏è Nessuna pianta salvata';
        }
      } catch (err) {
        console.error('Errore preview:', err);
      }
    }
    
    // Carica PNG all'avvio
    loadPNGFromBus();
    
    // Inizializza preview dopo 1 secondo
    setTimeout(() => {
      initPreviewMap();
      updatePreview();
    }, 1000);
  </script>
</body>
</html>

