<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>DMS ‚Ä¢ Slot Editor v3 - Sistema Unificato</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <link rel="stylesheet" href="../shared/dms-console.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    
    .container { display: flex; height: 100vh; }
    
    .sidebar {
      width: 380px;
      background: #0f2830;
      color: #d5f0e6;
      padding: 1rem;
      overflow-y: auto;
    }
    
    .sidebar h1 { font-size: 1.5rem; margin-bottom: 0.5rem; color: #4CAF50; }
    .sidebar h2 { font-size: 1.1rem; margin: 1rem 0 0.5rem; color: #81C784; }
    
    .section { margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #1a4a5a; }
    
    button {
      width: 100%;
      padding: 0.75rem;
      margin: 0.25rem 0;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }
    
    button:hover { background: #45a049; }
    button:disabled { background: #666; cursor: not-allowed; }
    button.secondary { background: #2196F3; }
    button.danger { background: #F44336; }
    button.active { background: #FF9800; }
    
    input[type="text"], input[type="number"], input[type="file"], input[type="range"] {
      width: 100%;
      padding: 0.5rem;
      margin: 0.25rem 0;
      background: #1a4a5a;
      color: #d5f0e6;
      border: 1px solid #2a5a6a;
      border-radius: 4px;
    }
    
    input[type="range"] {
      padding: 0;
      height: 30px;
      -webkit-appearance: none;
      appearance: none;
      background: linear-gradient(to right, #2196F3 0%, #2196F3 var(--value, 0%), #1a4a5a var(--value, 0%), #1a4a5a 100%);
      outline: none;
    }
    
    /* Thumb per Safari/Chrome */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      box-shadow: 0 0 2px rgba(0,0,0,0.5);
    }
    
    /* Thumb per Firefox */
    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 2px rgba(0,0,0,0.5);
    }
    
    label { display: block; margin: 0.5rem 0 0.25rem; font-size: 0.9rem; }
    
    .slider-container {
      background: #1a4a5a;
      padding: 0.75rem;
      border-radius: 4px;
      margin: 0.5rem 0;
    }
    
    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }
    
    .info { 
      background: #1a4a5a; 
      padding: 0.75rem; 
      border-radius: 4px; 
      font-size: 0.85rem;
      margin: 0.5rem 0;
    }
    
    .slot-list {
      max-height: 200px;
      overflow-y: auto;
      background: #1a4a5a;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.85rem;
    }
    
    .slot-item {
      padding: 0.25rem;
      margin: 0.25rem 0;
      background: #0f2830;
      border-radius: 2px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .slot-item button {
      width: auto;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      margin: 0;
    }
    
    #map { flex: 1; position: relative; }
    
    .reference-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      border: 2px solid #4CAF50;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      max-width: 400px;
      max-height: 500px;
      display: none;
    }
    
    .reference-panel.visible {
      display: block;
    }
    
    .reference-header {
      background: #4CAF50;
      color: white;
      padding: 8px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: move;
      font-weight: 600;
      font-size: 14px;
    }
    
    .reference-header button {
      background: transparent;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      padding: 0;
      width: 24px;
      height: 24px;
      margin: 0;
    }
    
    .reference-content {
      padding: 10px;
      overflow: auto;
      max-height: 450px;
    }
    
    .reference-content img {
      width: 100%;
      height: auto;
      display: block;
    }
    
    .leaflet-overlay-pane img {
      opacity: 0.7;
    }
    
    /* Stile tooltip numeri posteggi */
    .slot-number-label {
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      padding: 0 !important;
      margin: 0 !important;
    }
    
    .slot-number-label::before {
      display: none !important;
    }
    
    .slot-marker {
      background: rgba(76, 175, 80, 0.8);
      color: white;
      border: 2px solid #4CAF50;
      border-radius: 3px;
      font-weight: bold;
      font-size: 11px;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      cursor: pointer;
    }
    
    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin: 0.5rem 0;
    }
    
    .checkbox-container input[type="checkbox"] {
      width: auto;
      margin: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <h1>üéØ Slot Editor v3</h1>
      <p style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 1rem;">
        Sistema Unificato: Marker e Aree Personalizzabili
      </p>
      
      <!-- Navigazione Ecosistema -->
      <div class="section">
        <h2>üåê Navigazione</h2>
        <a href="bus_hub.html" style="display: block; width: 100%; padding: 0.75rem; margin: 0.25rem 0; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; text-align: center; text-decoration: none;">
          üöå BUS HUB
        </a>
        <a href="../index-grosseto.html" style="display: block; width: 100%; padding: 0.75rem; margin: 0.25rem 0; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; text-align: center; text-decoration: none;">
          üó∫Ô∏è Core Map
        </a>
        <a href="https://dmshubapp-hkvujnro.manus.space/dashboard-pa" style="display: block; width: 100%; padding: 0.75rem; margin: 0.25rem 0; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; text-align: center; text-decoration: none;">
          üìä Dashboard Admin
        </a>
      </div>
      
      <!-- 0. Riferimento -->  
      <div class="section">
        <h2>0Ô∏è‚É£ Immagine Riferimento</h2>
        <button id="btn-toggle-reference" class="secondary">üëÅÔ∏è Mostra/Nascondi Originale</button>
        <div class="info">Mostra l'immagine originale con i numeri dei posteggi</div>
      </div>
      
      <!-- 1. Carica Pianta -->
      <div class="section">
        <h2>1Ô∏è‚É£ Carica Pianta</h2>
        <input type="file" id="png-file" accept="image/png" />
        <button id="btn-load-png" class="secondary">üìÇ Carica PNG Trasparente</button>
        <div class="info" id="png-status">Nessuna pianta caricata</div>
      </div>
      
      <!-- 2. Posiziona Pianta -->
      <div class="section">
        <h2>2Ô∏è‚É£ Posiziona Pianta</h2>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>Rotazione pianta:</span>
            <span id="plant-rotation-value">0.0¬∞</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button id="btn-rotation-minus" class="secondary" style="width: 40px; padding: 8px;">‚àí</button>
            <input type="range" id="plant-rotation" min="0" max="360" value="0" step="0.1" style="flex: 1;" />
            <button id="btn-rotation-plus" class="secondary" style="width: 40px; padding: 8px;">+</button>
            <input type="number" id="plant-rotation-input" min="0" max="360" value="0" step="0.1" style="width: 80px; padding: 4px; text-align: center;" />
          </div>
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>Scala pianta:</span>
            <span id="plant-scale-value">100%</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button id="btn-scale-minus" class="secondary" style="width: 40px; padding: 8px;">‚àí</button>
            <input type="range" id="plant-scale" min="10" max="400" value="100" step="1" style="flex: 1;" />
            <button id="btn-scale-plus" class="secondary" style="width: 40px; padding: 8px;">+</button>
            <input type="number" id="plant-scale-input" min="10" max="400" value="100" step="0.1" style="width: 80px; padding: 4px; text-align: center;" />
          </div>
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>Opacit√† pianta:</span>
            <span id="plant-opacity-value">70%</span>
          </div>
          <input type="range" id="plant-opacity" min="0" max="100" value="70" step="5" />
        </div>
        
        <button id="btn-center-plant" class="secondary">üéØ Centra Pianta sulla Mappa</button>
        <button id="btn-save-plant-position" class="success" style="margin-top: 8px;">üíæ Salva Posizione Pianta</button>
        <button id="btn-save-marker-position" class="success" style="margin-top: 8px;">üíæ Salva Posizione Segnaposto</button>
        <div class="info">Trascina la pianta per posizionarla</div>
        <div id="plant-save-status" class="info" style="display: none; background: #4CAF50; color: white;"></div>
        <div id="marker-save-status" class="info" style="display: none; background: #4CAF50; color: white;"></div>
      </div>
      
      <!-- 3. Configura Posteggi -->
      <div class="section">
        <h2>3Ô∏è‚É£ Configura Posteggi</h2>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>Larghezza (m):</span>
            <span id="slot-width-value">2.5m</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button id="btn-width-minus" class="secondary" style="width: 30px; height: 30px; padding: 0; flex-shrink: 0; display: flex; align-items: center; justify-content: center;">‚àí</button>
            <input type="range" id="slot-width" min="1" max="50" value="2.5" step="0.1" style="flex: 1; min-width: 0;" />
            <button id="btn-width-plus" class="secondary" style="width: 30px; height: 30px; padding: 0; flex-shrink: 0; display: flex; align-items: center; justify-content: center;">+</button>
            <input type="number" id="slot-width-input" value="2.5" min="1" max="50" step="0.1" style="width: 60px;" />
          </div>
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>Altezza (m):</span>
            <span id="slot-height-value">5.0m</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button id="btn-height-minus" class="secondary" style="width: 30px; height: 30px; padding: 0; flex-shrink: 0; display: flex; align-items: center; justify-content: center;">‚àí</button>
            <input type="range" id="slot-height" min="1" max="50" value="5.0" step="0.1" style="flex: 1; min-width: 0;" />
            <button id="btn-height-plus" class="secondary" style="width: 30px; height: 30px; padding: 0; flex-shrink: 0; display: flex; align-items: center; justify-content: center;">+</button>
            <input type="number" id="slot-height-input" value="5.0" min="1" max="50" step="0.1" style="width: 60px;" />
          </div>
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>Rotazione:</span>
            <span id="slot-rotation-value">0.0¬∞</span>
          </div>
          <div style="display: flex; gap: 8px; align-items: center;">
            <button id="btn-slot-rotation-minus" class="secondary" style="width: 30px; height: 30px; padding: 0; flex-shrink: 0; display: flex; align-items: center; justify-content: center;">‚àí</button>
            <input type="range" id="slot-rotation" min="0" max="360" value="0" step="0.1" style="flex: 1; min-width: 0;" />
            <button id="btn-slot-rotation-plus" class="secondary" style="width: 30px; height: 30px; padding: 0; flex-shrink: 0; display: flex; align-items: center; justify-content: center;">+</button>
            <input type="number" id="slot-rotation-input" value="0.0" min="0" max="360" step="0.1" style="width: 60px;" />
          </div>
        </div>
        
        <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 12px;">
          <label style="margin: 0;">Numero:</label>
          <input type="number" id="slot-number" value="1" min="1" step="1" style="width: 80px;" />
        </div>
        
        <div class="checkbox-container">
          <input type="checkbox" id="keep-dimensions" />
          <label for="keep-dimensions" style="margin: 0;">Mantieni dimensioni fisse</label>
        </div>
        
        <button id="btn-add-mode" class="active">üìç Modalit√† Aggiungi Posteggio</button>
        <button id="btn-confirm-slot" class="success">‚úÖ Fissa Posteggio</button>
        <button id="btn-save-slots-position" class="success" style="margin-top: 8px;">üíæ Salva Posizione Posteggi</button>
        <div class="info" id="slot-count">0 posteggi aggiunti</div>
        <div id="slots-save-status" class="info" style="display: none; background: #4CAF50; color: white;"></div>
      </div>
      
      <!-- 4. Marker Personalizzabili -->
      <div class="section">
        <h2>üìç Marker Personalizzabili</h2>
        <button id="btn-add-marker" class="active">üìç Aggiungi Marker</button>
        <div class="info" id="marker-count">0 marker aggiunti</div>
        <div class="slot-list" id="marker-list" style="max-height: 150px; overflow-y: auto;">
          <div style="opacity: 0.6;">Nessun marker</div>
        </div>
      </div>
      
      <!-- 5. Aree Personalizzabili -->
      <div class="section">
        <h2>üìê Aree Personalizzabili</h2>
        <button id="btn-draw-area" class="active">üìê Disegna Area</button>
        <button id="btn-finish-area" class="success" style="display: none;">‚úÖ Completa Area</button>
        <button id="btn-cancel-area" class="danger" style="display: none;">‚ùå Annulla</button>
        <div class="info" id="area-drawing-info" style="display: none; background: #FF9800; color: white;">Click per aggiungere vertici, doppio-click per chiudere</div>
        <div class="info" id="area-count">0 aree aggiunte</div>
        <div class="slot-list" id="area-list" style="max-height: 150px; overflow-y: auto;">
          <div style="opacity: 0.6;">Nessuna area</div>
        </div>
      </div>
      
      <!-- 6. Lista Posteggi -->
      <div class="section">
        <h2>4Ô∏è‚É£ Posteggi Aggiunti (<span id="total-slots">0</span>)</h2>
        <div class="slot-list" id="slot-list">
          <div style="opacity: 0.6;">Nessun posteggio</div>
        </div>
        <button id="btn-clear-all" class="danger">üóëÔ∏è Cancella Tutti</button>
      </div>
      
      <!-- 5. Esporta -->
      <div class="section">
        <h2>5Ô∏è‚É£ Esporta</h2>
        <button id="btn-export-json" class="secondary">üíæ Esporta GeoJSON</button>
        <button id="btn-export-dashboard" class="success">üìä Esporta per Dashboard Admin</button>
        <button id="btn-save-bus">üöå Salva nel Bus</button>
        <div class="info" id="export-status">Pronto per esportare</div>
      </div>
      
      <!-- 5b. Importa -->
      <div class="section">
        <h2>üì• Importa Configurazione</h2>
        <input type="file" id="import-json-file" accept=".json" style="display: none;">
        <button id="btn-import-json" class="primary">üì• Carica JSON</button>
        <div class="info" id="import-status">Seleziona un file JSON da importare</div>
      </div>
      
      <!-- 6. Reset Pianta -->
      <div class="section">
        <h2>6Ô∏è‚É£ Reset Pianta</h2>
        <button id="btn-reset-plant" class="danger">üßπ Reset Pianta Completo</button>
        <div class="info" style="font-size: 0.85rem; color: #ff9800; margin-top: 0.5rem;">
          ‚ö†Ô∏è Cancella TUTTI i dati salvati (posteggi, marker, aree, pianta). Azione irreversibile!
        </div>
      </div>
    </aside>
    
    <div id="map">
    <div id="reference-panel" class="reference-panel">
      <div class="reference-header" id="reference-header">
        <span>üì∑ Immagine Originale</span>
        <button id="btn-close-reference">‚úï</button>
      </div>
      <div class="reference-content" id="reference-content">
        <img id="reference-image" src="" alt="Immagine originale" style="transform-origin: center center; cursor: move;" />
      </div>
      <div class="reference-controls" style="padding: 8px; background: #f5f5f5; border-top: 1px solid #ddd;">
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
          <span style="font-size: 12px; min-width: 50px;">Zoom:</span>
          <button id="btn-ref-zoom-out" style="padding: 4px 8px; font-size: 14px;">‚àí</button>
          <input type="range" id="ref-zoom" min="50" max="300" value="100" step="10" style="flex: 1;" />
          <button id="btn-ref-zoom-in" style="padding: 4px 8px; font-size: 14px;">+</button>
          <span id="ref-zoom-value" style="font-size: 12px; min-width: 45px;">100%</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
          <span style="font-size: 12px; min-width: 50px;">Ruota:</span>
          <button id="btn-ref-rotate-left" style="padding: 4px 8px; font-size: 14px;">‚Ü∂</button>
          <input type="range" id="ref-rotation" min="0" max="360" value="0" step="1" style="flex: 1;" />
          <button id="btn-ref-rotate-right" style="padding: 4px 8px; font-size: 14px;">‚Ü∑</button>
          <span id="ref-rotation-value" style="font-size: 12px; min-width: 35px;">0¬∞</span>
        </div>
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
          <span style="font-size: 12px; min-width: 50px;">Sposta:</span>
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; flex: 1;">
            <div></div>
            <button id="btn-ref-up" style="padding: 4px; font-size: 14px;">‚¨ÜÔ∏è</button>
            <div></div>
            <button id="btn-ref-left" style="padding: 4px; font-size: 14px;">‚¨ÖÔ∏è</button>
            <button id="btn-ref-center" style="padding: 4px; font-size: 10px;">üéØ</button>
            <button id="btn-ref-right" style="padding: 4px; font-size: 14px;">‚û°Ô∏è</button>
            <div></div>
            <button id="btn-ref-down" style="padding: 4px; font-size: 14px;">‚¨áÔ∏è</button>
            <div></div>
          </div>
        </div>
        <button id="btn-ref-reset" style="width: 100%; margin-top: 4px; padding: 4px; font-size: 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">üîÑ Reset</button>
      </div>
    </div>
  </div>
  </div>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="../shared/dms-bus.js"></script>
  <script>
    // Funzione per calcolare area poligono (algoritmo Shoelace)
    function calculatePolygonArea(coordinates) {
      if (!coordinates || coordinates.length < 3) return 0;
      
      let area = 0;
      for (let i = 0; i < coordinates.length; i++) {
        const j = (i + 1) % coordinates.length;
        area += coordinates[i][1] * coordinates[j][0];
        area -= coordinates[i][0] * coordinates[j][1];
      }
      area = Math.abs(area / 2);
      
      // Converti da gradi quadrati a metri quadrati (approssimazione)
      const lat = coordinates[0][0];
      const metersPerDegreeLat = 111320;
      const metersPerDegreeLng = 111320 * Math.cos(lat * Math.PI / 180);
      area = area * metersPerDegreeLat * metersPerDegreeLng;
      
      return area;
    }
    
    // Console si auto-inizializza da dms-console.js
    // Aspetta che sia pronta prima di loggare
    setTimeout(() => {
      DMSConsole.log('üöÄ Slot Editor v3 - Sistema Unificato inizializzato');
    }, 100);
    
    // NOTA: Caricamento automatico dal BUS spostato dopo inizializzazione variabili (vedi sotto)
    
    // Inizializza mappa su Grosseto
    const map = L.map('map').setView([42.7589, 11.1135], 17);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors',
      maxZoom: 20
    }).addTo(map);
    
    // Crea custom pane per posteggi (sopra piantina ma sotto marker)
    map.createPane('slotsPane');
    map.getPane('slotsPane').style.zIndex = 450; // overlayPane=400, markerPane=600
    
    // Funzione per aggiornare font-size tooltip in base allo zoom
    function updateTooltipFontSize() {
      try {
        const zoom = map.getZoom();
        // Calcola font size in base allo zoom (zoom 17 = 14px, scala proporzionalmente)
        const baseFontSize = 14;
        const baseZoom = 17;
        const fontSize = Math.max(8, Math.min(24, baseFontSize * Math.pow(1.15, zoom - baseZoom)));
        
        console.log(`üîç ZOOM ${zoom} ‚Üí fontSize ${fontSize.toFixed(1)}px`);
        
        // Aspetta che il DOM sia aggiornato
        setTimeout(() => {
          // Aggiorna font-size di tutti i tooltip usando DOM
          const tooltipLabels = document.querySelectorAll('.leaflet-tooltip-pane .slot-number-label div');
          console.log(`üîé Trovati ${tooltipLabels.length} tooltip nel DOM`);
          
          tooltipLabels.forEach(label => {
            label.style.fontSize = `${fontSize}px`;
          });
          
          console.log(`‚úÖ Aggiornati ${tooltipLabels.length} tooltip`);
        }, 100); // Aumentato timeout per dare tempo al DOM
      } catch (err) {
        console.error('‚ùå Errore aggiornamento font tooltip:', err);
      }
    }
    
    // Listener zoom per aggiornare dimensione font tooltip
    map.on('zoomend', updateTooltipFontSize);
    
    // Variabili globali
    let pdfBlob = null;
    let pdfBlobOriginal = null; // Blob originale non ruotato
    let pdfOverlay = null;
    let plantBounds = null;
    let plantRotation = 0;
    let plantScale = 1.0;
    let slotRotation = 0;
    let slots = [];
    let markers = [];
    let areas = [];
    let addMode = false;
    let markerMode = false;
    let areaDrawingMode = false;
    let currentAreaVertices = [];
    let currentAreaMarkers = [];
    let currentAreaPolyline = null;
    let slotCounter = 1;
    let markerCounter = 1;
    let areaCounter = 1;
    let plantMarker = null; // Marker per trascinare pianta
    let plantImageSize = { width: 500, height: 400 }; // Dimensioni immagine corrente
    
    // Carica automaticamente PNG dal BUS
    (async () => {
      try {
        DMSConsole.log('üîç Cerco PNG nel BUS...');
        
        // Carica PNG trasparente
        const blobTransparent = await DMSBUS.getBlob('png_transparent');
        if (blobTransparent) {
          pdfBlob = blobTransparent;
          pdfBlobOriginal = blobTransparent; // Salva originale per rotazioni
          
          // Carica immagine per ottenere dimensioni reali
          const img = new Image();
          img.src = URL.createObjectURL(blobTransparent);
          img.onload = () => {
            plantImageSize = { width: img.width, height: img.height };
            DMSConsole.log('‚úÖ Dimensioni immagine: ' + img.width + 'x' + img.height);
            URL.revokeObjectURL(img.src);
          };
          
          // Prova a caricare posizione salvata
          const savedPosition = await DMSBUS.getJSON('plant_position');
          if (savedPosition) {
            console.log('üìû Posizione salvata caricata:', savedPosition);
            
            // NUOVO: Usa centro + dimensioni originali (compatibile con vecchio formato)
            if (savedPosition.center && savedPosition.imageSize) {
              // Nuovo formato: centro + dimensioni
              const center = savedPosition.center;
              const size = savedPosition.imageSize;
              plantRotation = savedPosition.rotation || 0;
              plantScale = savedPosition.scale || 1.0;
              
              // Calcola bounds da centro + dimensioni + scala
              const corners = calculatePlantBounds(
                center,
                size.width,
                size.height,
                0, // Rotazione applicata dopo
                plantScale
              );
              
              // Converti array corners in LatLngBounds
              plantBounds = L.latLngBounds([
                corners[0], // top-left
                corners[2]  // bottom-right
              ]);
              
              console.log('‚úÖ Bounds calcolati da centro:', plantBounds);
            } else if (savedPosition.corners) {
              // Vecchio formato: corners (retrocompatibilit√†)
              plantBounds = L.latLngBounds([
                savedPosition.corners[0],
                savedPosition.corners[2]
              ]);
              plantRotation = savedPosition.rotation || 0;
              plantScale = savedPosition.scale || 1.0;
              
              console.log('‚ö†Ô∏è Usato vecchio formato corners');
            } else {
              console.warn('‚ö†Ô∏è Formato posizione salvata non riconosciuto');
              return;
            }
            
            // Aggiorna controlli UI
            document.getElementById('plant-rotation').value = plantRotation;
            document.getElementById('plant-rotation-input').value = plantRotation.toFixed(1);
            document.getElementById('plant-rotation-value').textContent = plantRotation.toFixed(1) + '¬∞';
            
            document.getElementById('plant-scale').value = plantScale * 100;
            document.getElementById('plant-scale-input').value = (plantScale * 100).toFixed(0);
            document.getElementById('plant-scale-value').textContent = (plantScale * 100).toFixed(0) + '%';
            
            if (savedPosition.opacity) {
              document.getElementById('plant-opacity').value = savedPosition.opacity;
              document.getElementById('plant-opacity-value').textContent = savedPosition.opacity + '%';
            }
            
            // Applica rotazione salvata
            if (plantRotation > 0) {
              await updateRotation(plantRotation);
            }
            
            document.getElementById('png-status').textContent = '‚úÖ PNG e posizione ripristinati dal BUS';
          } else {
            // Posizione di default
            const center = map.getCenter();
            plantBounds = L.latLngBounds([
              [center.lat + 0.002, center.lng - 0.002],
              [center.lat - 0.002, center.lng + 0.002]
            ]);
            document.getElementById('png-status').textContent = '‚úÖ PNG trasparente caricato dal BUS';
          }
          
          updatePlantOverlay();
          
          // Carica posizione segnaposto da localStorage (sovrascrive BUS se presente)
          try {
            const savedMarkerPos = localStorage.getItem('plant_marker_position');
            if (savedMarkerPos) {
              const markerData = JSON.parse(savedMarkerPos);
              console.log('üíæ Caricamento posizione segnaposto da localStorage:', markerData);
              
              // Posiziona marker rosso
              const markerLatLng = L.latLng(markerData.lat, markerData.lng);
              
              if (plantMarker) {
                plantMarker.setLatLng(markerLatLng);
              } else {
                plantMarker = L.marker(markerLatLng, {
                  draggable: true,
                  icon: L.divIcon({
                    className: 'plant-marker',
                    html: '<div style="background: #ff4444; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">M</div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                  })
                }).addTo(map);
                
                // Listener drag marker
                plantMarker.on('drag', () => {
                  if (plantBounds && plantImageSize) {
                    const newCenter = plantMarker.getLatLng();
                    plantBounds = calculatePlantBounds(newCenter, plantImageSize.width, plantImageSize.height, plantScale, plantRotation);
                    updatePlantOverlay();
                  }
                });
              }
              
              // Applica parametri salvati
              if (markerData.rotation !== undefined) {
                plantRotation = markerData.rotation;
                document.getElementById('plant-rotation').value = plantRotation;
                document.getElementById('plant-rotation-input').value = plantRotation.toFixed(1);
                document.getElementById('plant-rotation-value').textContent = plantRotation.toFixed(1) + '¬∞';
              }
              
              if (markerData.scale !== undefined) {
                plantScale = markerData.scale;
                document.getElementById('plant-scale').value = plantScale * 100;
                document.getElementById('plant-scale-input').value = (plantScale * 100).toFixed(0);
                document.getElementById('plant-scale-value').textContent = (plantScale * 100).toFixed(0) + '%';
              }
              
              if (markerData.opacity !== undefined) {
                document.getElementById('plant-opacity').value = markerData.opacity;
                document.getElementById('plant-opacity-value').textContent = markerData.opacity + '%';
              }
              
              // Ricalcola bounds piantina dal marker
              if (plantImageSize) {
                plantBounds = calculatePlantBounds(markerLatLng, plantImageSize.width, plantImageSize.height, plantScale, plantRotation);
                
                // Applica rotazione
                if (plantRotation > 0) {
                  await updateRotation(plantRotation);
                }
                
                updatePlantOverlay();
                console.log('‚úÖ Posizione segnaposto ripristinata da localStorage');
                document.getElementById('png-status').textContent = '‚úÖ PNG e segnaposto ripristinati';
              }
            }
          } catch (err) {
            console.error('‚ùå Errore caricamento segnaposto:', err);
          }
          
          DMSConsole.log('‚úÖ PNG trasparente caricato dal BUS');
        } else {
          DMSConsole.log('‚ö†Ô∏è png_transparent non trovato nel BUS');
        }
        
        // Carica PNG originale
        const blobOriginal = await DMSBUS.getBlob('png_original');
        if (blobOriginal) {
          const url = URL.createObjectURL(blobOriginal);
          document.getElementById('reference-image').src = url;
          DMSConsole.log('‚úÖ PNG originale caricato dal BUS');
        } else {
          DMSConsole.log('‚ö†Ô∏è png_original non trovato nel BUS');
        }
        
        // Carica posteggi salvati
        console.log('üîç Tentativo caricamento posteggi dal BUS...');
        const stallsGeoJSON = await DMSBUS.getJSON('stalls_geojson');
        console.log('üì¶ Dati BUS:', stallsGeoJSON);
        
        if (stallsGeoJSON && stallsGeoJSON.features) {
          console.log(`üÖøÔ∏è Caricamento ${stallsGeoJSON.features.length} posteggi dal BUS...`);
          
          stallsGeoJSON.features.forEach(feature => {
            const props = feature.properties;
            const [lng, lat] = feature.geometry.coordinates;
            
            // Estrai dimensioni da stringa "2.5m √ó 5.0m"
            const dimMatch = props.dimensions.match(/([\d.]+)m\s*√ó\s*([\d.]+)m/);
            const width = dimMatch ? parseFloat(dimMatch[1]) : 2.5;
            const height = dimMatch ? parseFloat(dimMatch[2]) : 5.0;
            const rotation = props.orientation || 0;
            const number = props.number || slotCounter;
            
            // Calcola corner geografici
            const center = { lat, lng };
            const corners = calculateSlotBounds(center, width, height, rotation);
            
            // Crea polygon verde
            const polygon = L.polygon(corners, {
              color: '#4CAF50',
              weight: 2,
              fillColor: '#4CAF50',
              fillOpacity: 0.9,
              className: 'fixed-slot',
              pane: 'slotsPane'
            }).addTo(map);
            
            // Aggiungi tooltip con numero
            const tooltip = L.tooltip({
              permanent: true,
              direction: 'center',
              className: 'slot-number-label',
              offset: [0, 0]
            })
            .setContent(`<div style="font-weight: bold; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">${number}</div>`)
            .setLatLng(center);
            
            polygon.bindTooltip(tooltip).openTooltip();
            
            // Aggiungi popup
            const popupContent = `
              <div style="font-family: sans-serif; min-width: 200px;">
                <h3 style="margin: 0 0 10px 0; color: #4CAF50;">üÖøÔ∏è Posteggio #${number}</h3>
                <p style="margin: 5px 0;"><strong>üìè Dimensioni:</strong> ${width.toFixed(1)}m √ó ${height.toFixed(1)}m</p>
                <p style="margin: 5px 0;"><strong>üîÑ Rotazione:</strong> ${rotation.toFixed(1)}¬∞</p>
                <p style="margin: 5px 0;"><strong>üìç Coordinate:</strong></p>
                <p style="margin: 0 0 10px 15px; font-size: 11px; color: #666;">
                  Lat: ${lat.toFixed(8)}<br>
                  Lng: ${lng.toFixed(8)}
                </p>
                <button onclick="openVetrinaEditor(${number}, ${lat}, ${lng}, ${width}, ${height}, ${rotation})" 
                        style="width: 100%; padding: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                  üè™ Vai a Vetrina Editor
                </button>
              </div>
            `;
            polygon.bindPopup(popupContent);
            
            // Aggiungi a lista slots
            slots.push({
              number,
              lat,
              lng,
              width,
              height,
              rotation,
              polygon,
              tooltip
            });
            
            // Aggiorna counter
            if (number >= slotCounter) {
              slotCounter = number + 1;
            }
          });
          
          updateSlotList();
          console.log(`‚úÖ ${slots.length} posteggi caricati dal BUS`);
          document.getElementById('export-status').textContent = `‚úÖ ${slots.length} posteggi caricati dal BUS`;
        }
      } catch (err) {
        console.error('‚ùå Errore caricamento BUS:', err);
        DMSConsole.log('‚ùå Errore caricamento BUS: ' + err.message);
      }
      
      // Carica posteggi da localStorage (se non caricati dal BUS)
      if (slots.length === 0) {
        try {
          const savedSlots = localStorage.getItem('slots_positions');
          console.log('üîç Tentativo caricamento posteggi da localStorage...');
          
          if (savedSlots) {
            const slotsData = JSON.parse(savedSlots);
            console.log(`üíæ ${slotsData.length} posteggi trovati in localStorage`);
            
            slotsData.forEach(slotData => {
              const { number, lat, lng, width, height, rotation } = slotData;
              
              // Calcola corner geografici
              const center = { lat, lng };
              const corners = calculateSlotBounds(center, width, height, rotation);
              
              // Crea polygon verde
              const polygon = L.polygon(corners, {
                color: '#4CAF50',
                weight: 2,
                fillColor: '#4CAF50',
                fillOpacity: 0.9,
                className: 'fixed-slot',
                pane: 'slotsPane'
              }).addTo(map);
              
              // Aggiungi tooltip
              const tooltip = L.tooltip({
                permanent: true,
                direction: 'center',
                className: 'slot-number-label',
                offset: [0, 0]
              })
              .setContent(`<div style="font-weight: bold; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">${number}</div>`)
              .setLatLng(center);
              
              polygon.bindTooltip(tooltip).openTooltip();
              
              // Aggiungi popup
              const popupContent = `
                <div style="font-family: sans-serif; min-width: 200px;">
                  <h3 style="margin: 0 0 10px 0; color: #4CAF50;">üÖøÔ∏è Posteggio #${number}</h3>
                  <p style="margin: 5px 0;"><strong>üìè Dimensioni:</strong> ${width.toFixed(1)}m √ó ${height.toFixed(1)}m</p>
                  <p style="margin: 5px 0;"><strong>üîÑ Rotazione:</strong> ${rotation.toFixed(1)}¬∞</p>
                  <p style="margin: 5px 0;"><strong>üìç Coordinate:</strong></p>
                  <p style="margin: 0 0 10px 15px; font-size: 11px; color: #666;">
                    Lat: ${lat.toFixed(8)}<br>
                    Lng: ${lng.toFixed(8)}
                  </p>
                  <button onclick="openVetrinaEditor(${number}, ${lat}, ${lng}, ${width}, ${height}, ${rotation})" 
                          style="width: 100%; padding: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                    üè™ Vai a Vetrina Editor
                  </button>
                </div>
              `;
              polygon.bindPopup(popupContent);
              
              // Aggiungi a lista
              slots.push({
                number,
                lat,
                lng,
                width,
                height,
                rotation,
                polygon,
                tooltip
              });
              
              // Aggiorna counter
              if (number >= slotCounter) {
                slotCounter = number + 1;
              }
            });
            
            updateSlotList();
            console.log(`‚úÖ ${slots.length} posteggi caricati da localStorage`);
            document.getElementById('export-status').textContent = `‚úÖ ${slots.length} posteggi caricati da localStorage`;
            
            // Aggiorna font-size tooltip in base allo zoom corrente
            setTimeout(() => {
              updateTooltipFontSize();
            }, 200);
          } else {
            console.log('‚ö†Ô∏è Nessun posteggio salvato in localStorage');
          }
        } catch (err) {
          console.error('‚ùå Errore caricamento localStorage:', err);
        }
      }
    })();
    
    // Funzione per calcolare bounds posteggio da dimensioni in metri
    function calculateSlotBounds(center, widthMeters, heightMeters, rotation) {
      // Calcola offset in metri (conversione metri ‚Üí gradi lat/lng)
      const latOffset = (heightMeters / 2) / 111320; // 1 grado lat ‚âà 111.32 km
      const lngOffset = (widthMeters / 2) / (111320 * Math.cos(center.lat * Math.PI / 180));
      
      // Corner base (senza rotazione)
      const corners = [
        [center.lat + latOffset, center.lng - lngOffset], // top-left
        [center.lat + latOffset, center.lng + lngOffset], // top-right
        [center.lat - latOffset, center.lng + lngOffset], // bottom-right
        [center.lat - latOffset, center.lng - lngOffset]  // bottom-left
      ];
      
      // Applica rotazione (compensando proiezione Mercatore)
      if (rotation !== 0) {
        const rad = rotation * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        
        // Fattore di compensazione Mercatore alla latitudine corrente
        const mercatorFactor = Math.cos(center.lat * Math.PI / 180);
        
        return corners.map(([lat, lng]) => {
          const dLat = lat - center.lat;
          const dLng = (lng - center.lng) * mercatorFactor; // Scala lng per compensare
          
          // Ruota in spazio "piatto"
          const rotatedLat = dLat * cos - dLng * sin;
          const rotatedLng = (dLat * sin + dLng * cos) / mercatorFactor; // Descala lng
          
          return [
            center.lat + rotatedLat,
            center.lng + rotatedLng
          ];
        });
      }
      
      return corners;
    }
    
    // Funzione per calcolare bounds ruotati e scalati
    function calculatePlantBounds(center, width, height, rotation, scale) {
      const scaledWidth = width * scale;
      const scaledHeight = height * scale;
      
      // Calcola offset in metri
      const latOffset = (scaledHeight / 2) / 111320; // 1 grado lat ‚âà 111.32 km
      const lngOffset = (scaledWidth / 2) / (111320 * Math.cos(center.lat * Math.PI / 180));
      
      // Corner base (senza rotazione)
      const corners = [
        [center.lat + latOffset, center.lng - lngOffset], // top-left
        [center.lat + latOffset, center.lng + lngOffset], // top-right
        [center.lat - latOffset, center.lng + lngOffset], // bottom-right
        [center.lat - latOffset, center.lng - lngOffset]  // bottom-left
      ];
      
      // Applica rotazione (compensando proiezione Mercatore)
      if (rotation !== 0) {
        const rad = rotation * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        
        // Fattore di compensazione Mercatore alla latitudine corrente
        const mercatorFactor = Math.cos(center.lat * Math.PI / 180);
        
        return corners.map(([lat, lng]) => {
          const dLat = lat - center.lat;
          const dLng = (lng - center.lng) * mercatorFactor; // Scala lng per compensare
          
          // Ruota in spazio "piatto"
          const rotatedLat = dLat * cos - dLng * sin;
          const rotatedLng = (dLat * sin + dLng * cos) / mercatorFactor; // Descala lng
          
          return [
            center.lat + rotatedLat,
            center.lng + rotatedLng
          ];
        });
      }
      
      return corners;
    }
    
    // Funzione per aggiornare overlay pianta
    let isUpdatingPlant = false; // Flag per evitare loop
    function updatePlantOverlay() {
      if (!pdfBlob || !plantBounds || isUpdatingPlant) return;
      isUpdatingPlant = true;
      
      const center = plantMarker ? plantMarker.getLatLng() : map.getCenter();
      // NON ruotiamo le coordinate, solo scaliamo con dimensioni corrette
      const corners = calculatePlantBounds(center, plantImageSize.width, plantImageSize.height, 0, plantScale);
      const bounds = L.latLngBounds([corners[0], corners[2]]);
      
      if (pdfOverlay) {
        map.removeLayer(pdfOverlay);
      }
      
      const url = URL.createObjectURL(pdfBlob);
      pdfOverlay = L.imageOverlay(url, bounds, {
        opacity: parseFloat(document.getElementById('plant-opacity').value) / 100,
        interactive: false,
        zIndex: 400
      }).addTo(map);
      
      // Aggiungi/aggiorna marker trascinabile
      if (!plantMarker) {
        const redIcon = L.divIcon({
          className: 'plant-marker',
          html: '<div style="background: red; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); cursor: move;">M</div>',
          iconSize: [30, 30],
          iconAnchor: [15, 15]
        });
        
        plantMarker = L.marker(center, { 
          icon: redIcon,
          draggable: true,
          zIndexOffset: 1000
        }).addTo(map);
        
        // Usa dragend invece di drag per evitare troppi aggiornamenti
        plantMarker.on('drag', () => {
          if (pdfOverlay && !isUpdatingPlant) {
            const newCenter = plantMarker.getLatLng();
            const corners = calculatePlantBounds(newCenter, plantImageSize.width, plantImageSize.height, 0, plantScale);
            const newBounds = L.latLngBounds([corners[0], corners[2]]);
            pdfOverlay.setBounds(newBounds);
          }
        });
        
        plantMarker.on('dragend', () => {
          DMSConsole.log('‚úÖ Pianta riposizionata');
        });
        
        DMSConsole.log('‚úÖ Marker pianta aggiunto - trascina per posizionare');
      } else {
        plantMarker.setLatLng(center);
      }
      
      plantBounds = bounds;
      isUpdatingPlant = false;
      DMSConsole.log('‚úÖ Pianta aggiornata');
    }
    
    // Toggle pannello riferimento
    document.getElementById('btn-toggle-reference').addEventListener('click', () => {
      const panel = document.getElementById('reference-panel');
      panel.classList.toggle('visible');
    });
    
    // Chiudi pannello riferimento
    document.getElementById('btn-close-reference').addEventListener('click', () => {
      document.getElementById('reference-panel').classList.remove('visible');
    });
    
    // Rendi pannello riferimento draggable
    const refPanel = document.getElementById('reference-panel');
    const refHeader = document.getElementById('reference-header');
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    
    refHeader.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);
    
    function dragStart(e) {
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;
      if (e.target === refHeader || refHeader.contains(e.target)) {
        isDragging = true;
      }
    }
    
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        xOffset = currentX;
        yOffset = currentY;
        setTranslate(currentX, currentY, refPanel);
      }
    }
    
    function dragEnd(e) {
      initialX = currentX;
      initialY = currentY;
      isDragging = false;
    }
    
    function setTranslate(xPos, yPos, el) {
      el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }
    
    // Controlli immagine riferimento
    let refZoom = 100;
    let refRotation = 0;
    let refPanX = 0;
    let refPanY = 0;
    
    function updateReferenceImage() {
      const img = document.getElementById('reference-image');
      img.style.transform = `scale(${refZoom / 100}) rotate(${refRotation}deg) translate(${refPanX}px, ${refPanY}px)`;
    }
    
    // Zoom slider
    document.getElementById('ref-zoom').addEventListener('input', (e) => {
      refZoom = parseInt(e.target.value);
      document.getElementById('ref-zoom-value').textContent = refZoom + '%';
      updateReferenceImage();
    });
    
    // Zoom pulsanti
    document.getElementById('btn-ref-zoom-in').addEventListener('click', () => {
      refZoom = Math.min(300, refZoom + 10);
      document.getElementById('ref-zoom').value = refZoom;
      document.getElementById('ref-zoom-value').textContent = refZoom + '%';
      updateReferenceImage();
    });
    
    document.getElementById('btn-ref-zoom-out').addEventListener('click', () => {
      refZoom = Math.max(50, refZoom - 10);
      document.getElementById('ref-zoom').value = refZoom;
      document.getElementById('ref-zoom-value').textContent = refZoom + '%';
      updateReferenceImage();
    });
    
    // Rotazione slider
    document.getElementById('ref-rotation').addEventListener('input', (e) => {
      refRotation = parseInt(e.target.value);
      document.getElementById('ref-rotation-value').textContent = refRotation + '¬∞';
      updateReferenceImage();
    });
    
    // Rotazione pulsanti
    document.getElementById('btn-ref-rotate-left').addEventListener('click', () => {
      refRotation = (refRotation - 15 + 360) % 360;
      document.getElementById('ref-rotation').value = refRotation;
      document.getElementById('ref-rotation-value').textContent = refRotation + '¬∞';
      updateReferenceImage();
    });
    
    document.getElementById('btn-ref-rotate-right').addEventListener('click', () => {
      refRotation = (refRotation + 15) % 360;
      document.getElementById('ref-rotation').value = refRotation;
      document.getElementById('ref-rotation-value').textContent = refRotation + '¬∞';
      updateReferenceImage();
    });
    
    // Reset
    document.getElementById('btn-ref-reset').addEventListener('click', () => {
      refZoom = 100;
      refRotation = 0;
      refPanX = 0;
      refPanY = 0;
      document.getElementById('ref-zoom').value = 100;
      document.getElementById('ref-zoom-value').textContent = '100%';
      document.getElementById('ref-rotation').value = 0;
      document.getElementById('ref-rotation-value').textContent = '0¬∞';
      updateReferenceImage();
    });
    
    // Pulsanti freccia per spostare immagine
    const panStep = 20; // pixel per click
    
    document.getElementById('btn-ref-up').addEventListener('click', () => {
      refPanY += panStep;
      updateReferenceImage();
    });
    
    document.getElementById('btn-ref-down').addEventListener('click', () => {
      refPanY -= panStep;
      updateReferenceImage();
    });
    
    document.getElementById('btn-ref-left').addEventListener('click', () => {
      refPanX += panStep;
      updateReferenceImage();
    });
    
    document.getElementById('btn-ref-right').addEventListener('click', () => {
      refPanX -= panStep;
      updateReferenceImage();
    });
    
    document.getElementById('btn-ref-center').addEventListener('click', () => {
      refPanX = 0;
      refPanY = 0;
      updateReferenceImage();
    });
    
    // Pan immagine con drag (FIXATO: direzione corretta)
    const refContent = document.getElementById('reference-content');
    const refImage = document.getElementById('reference-image');
    let isImageDragging = false;
    let imageStartX, imageStartY, imagePanStartX, imagePanStartY;
    
    refImage.addEventListener('mousedown', (e) => {
      isImageDragging = true;
      imageStartX = e.clientX;
      imageStartY = e.clientY;
      imagePanStartX = refPanX;
      imagePanStartY = refPanY;
      e.preventDefault();
    });
    
    document.addEventListener('mousemove', (e) => {
      if (isImageDragging) {
        const deltaX = e.clientX - imageStartX;
        const deltaY = e.clientY - imageStartY;
        refPanX = imagePanStartX + deltaX;
        refPanY = imagePanStartY + deltaY;
        updateReferenceImage();
      }
    });
    
    document.addEventListener('mouseup', () => {
      isImageDragging = false;
    });
    
    // Zoom con rotella mouse
    refContent.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -10 : 10;
      refZoom = Math.max(50, Math.min(300, refZoom + delta));
      document.getElementById('ref-zoom').value = refZoom;
      document.getElementById('ref-zoom-value').textContent = refZoom + '%';
      updateReferenceImage();
    });

    
    // Carica PNG
    document.getElementById('btn-load-png').addEventListener('click', () => {
      const file = document.getElementById('png-file').files[0];
      if (!file) {
        alert('‚ö†Ô∏è Seleziona un file PNG prima!');
        return;
      }
      
      pdfBlob = file;
      pdfBlobOriginal = file; // Salva originale per rotazioni
      
      // Carica immagine per ottenere dimensioni reali
      const img = new Image();
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        plantImageSize = { width: img.width, height: img.height };
        DMSConsole.log('‚úÖ Dimensioni immagine: ' + img.width + 'x' + img.height);
        URL.revokeObjectURL(img.src);
        
        const center = map.getCenter();
        plantBounds = L.latLngBounds([
          [center.lat + 0.002, center.lng - 0.002],
          [center.lat - 0.002, center.lng + 0.002]
        ]);
        
        updatePlantOverlay();
        document.getElementById('png-status').textContent = `‚úÖ ${file.name} caricato`;
        DMSConsole.log(`‚úÖ PNG caricato: ${file.name}`);
      };
    });
    
    // Funzione per aggiornare rotazione
    async function updateRotation(value) {
      plantRotation = parseFloat(value);
      document.getElementById('plant-rotation-value').textContent = plantRotation.toFixed(1) + '¬∞';
      document.getElementById('plant-rotation').value = plantRotation;
      document.getElementById('plant-rotation-input').value = plantRotation;
      
      if (!pdfBlobOriginal) return;
      
      // Ruota fisicamente l'immagine con canvas
      const img = new Image();
      const url = URL.createObjectURL(pdfBlobOriginal);
      img.src = url;
      
      img.onload = async () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Calcola dimensioni canvas ruotato
        const rad = plantRotation * Math.PI / 180;
        const cos = Math.abs(Math.cos(rad));
        const sin = Math.abs(Math.sin(rad));
        canvas.width = img.width * cos + img.height * sin;
        canvas.height = img.width * sin + img.height * cos;
        
        // Ruota e disegna
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(rad);
        ctx.drawImage(img, -img.width / 2, -img.height / 2);
        
        // Crea nuovo Blob
        pdfBlob = await new Promise(resolve => {
          canvas.toBlob(blob => resolve(blob), 'image/png');
        });
        
        // Aggiorna dimensioni immagine
        plantImageSize = { width: canvas.width, height: canvas.height };
        
        URL.revokeObjectURL(url);
        updatePlantOverlay();
        DMSConsole.log('‚úÖ Immagine ruotata fisicamente: ' + plantRotation.toFixed(1) + '¬∞ (dim: ' + canvas.width + 'x' + canvas.height + ')');
      };
    }
    
    // Slider rotazione pianta
    document.getElementById('plant-rotation').addEventListener('input', (e) => {
      updateRotation(e.target.value);
    });
    
    // Input numerico rotazione
    document.getElementById('plant-rotation-input').addEventListener('input', (e) => {
      updateRotation(e.target.value);
    });
    
    // Pulsanti +/- rotazione (0.1¬∞ alla volta)
    document.getElementById('btn-rotation-minus').addEventListener('click', () => {
      updateRotation(Math.max(0, plantRotation - 0.1));
    });
    
    document.getElementById('btn-rotation-plus').addEventListener('click', () => {
      updateRotation(Math.min(360, plantRotation + 0.1));
    });
    
    // Funzione per aggiornare scala
    function updateScale(value) {
      plantScale = parseFloat(value) / 100; // Converti da percentuale (10-400) a scala (0.1-4.0)
      const displayValue = parseFloat(value).toFixed(1); // Mostra come percentuale con 1 decimale
      document.getElementById('plant-scale-value').textContent = displayValue + '%';
      document.getElementById('plant-scale').value = value;
      document.getElementById('plant-scale-input').value = value;
      updatePlantOverlay();
    }
    
    // Slider scala pianta
    document.getElementById('plant-scale').addEventListener('input', (e) => {
      updateScale(e.target.value);
    });
    
    // Input numerico scala
    document.getElementById('plant-scale-input').addEventListener('input', (e) => {
      updateScale(e.target.value);
    });
    
    // Pulsanti +/- scala (0.1% alla volta per precisione)
    document.getElementById('btn-scale-minus').addEventListener('click', () => {
      const currentValue = parseFloat(document.getElementById('plant-scale').value);
      const newValue = Math.max(10, Math.round((currentValue - 0.1) * 10) / 10);
      updateScale(newValue);
    });
    
    document.getElementById('btn-scale-plus').addEventListener('click', () => {
      const currentValue = parseFloat(document.getElementById('plant-scale').value);
      const newValue = Math.min(400, Math.round((currentValue + 0.1) * 10) / 10);
      updateScale(newValue);
    });
    
    // Slider opacit√† pianta
    document.getElementById('plant-opacity').addEventListener('input', (e) => {
      document.getElementById('plant-opacity-value').textContent = e.target.value + '%';
      if (pdfOverlay) {
        pdfOverlay.setOpacity(parseInt(e.target.value) / 100);
      }
    });
    
    // Centra pianta
    document.getElementById('btn-center-plant').addEventListener('click', () => {
      if (!pdfBlob) {
        alert('‚ö†Ô∏è Carica prima una pianta!');
        return;
      }
      map.setView([42.7589, 11.1135], 17);
      updatePlantOverlay();
    });
    
    // Salva posizione pianta nel BUS
    document.getElementById('btn-save-plant-position').addEventListener('click', async () => {
      if (!plantBounds) {
        alert('‚ö†Ô∏è Posiziona prima la pianta sulla mappa!');
        return;
      }
      
      try {
        // Salva CENTRO marker rosso + dimensioni originali (non bounds ruotati!)
        const center = plantMarker ? plantMarker.getLatLng() : map.getCenter();
        
        const plantPosition = {
          center: {
            lat: center.lat,
            lng: center.lng
          },
          imageSize: plantImageSize, // Dimensioni originali PNG
          rotation: plantRotation,
          scale: plantScale,
          opacity: parseInt(document.getElementById('plant-opacity').value),
          timestamp: new Date().toISOString()
        };
        
        console.log('üíæ Salvataggio posizione pianta:', plantPosition);
        
        await DMSBUS.putJSON('plant_position', plantPosition);
        
        const status = document.getElementById('plant-save-status');
        status.textContent = '‚úÖ Posizione pianta salvata!';
        status.style.display = 'block';
        setTimeout(() => {
          status.style.display = 'none';
        }, 3000);
        
      } catch (err) {
        alert('‚ùå Errore salvataggio: ' + err.message);
      }
    });
    
    // Salva posizione segnaposto (marker rosso) in localStorage
    document.getElementById('btn-save-marker-position').addEventListener('click', () => {
      if (!plantMarker) {
        alert('‚ö†Ô∏è Posiziona prima la pianta sulla mappa!');
        return;
      }
      
      try {
        const markerPos = plantMarker.getLatLng();
        
        const markerPosition = {
          lat: markerPos.lat,
          lng: markerPos.lng,
          imageSize: plantImageSize,
          rotation: plantRotation,
          scale: plantScale,
          opacity: parseInt(document.getElementById('plant-opacity').value),
          timestamp: new Date().toISOString()
        };
        
        // Salva in localStorage
        localStorage.setItem('plant_marker_position', JSON.stringify(markerPosition));
        
        console.log('üíæ Posizione segnaposto salvata:', markerPosition);
        
        const status = document.getElementById('marker-save-status');
        status.textContent = '‚úÖ Posizione segnaposto salvata!';
        status.style.display = 'block';
        setTimeout(() => {
          status.style.display = 'none';
        }, 3000);
      } catch (err) {
        console.error('‚ùå Errore salvataggio segnaposto:', err);
        alert('‚ùå Errore durante il salvataggio!');
      }
    });
    
    // Variabili per posteggio temporaneo
    let tempSlot = null;
    let slotWidth = 2.5;  // Larghezza standard posteggio auto
    let slotHeight = 5.0; // Lunghezza standard posteggio auto
    
    // Scala conversione metri ‚Üí pixel (calibrata per posteggi visibili)
    // 2.5m √ó 10 = 25px (piccolo ma visibile)
    const meterToPixel = 10;
    
    // Funzione per aprire Vetrina Editor con dati posteggio
    function openVetrinaEditor(number, lat, lng, width, height, rotation) {
      const stallData = {
        number: number,
        lat: lat,
        lng: lng,
        width: width,
        height: height,
        rotation: rotation,
        timestamp: new Date().toISOString()
      };
      
      // Salva nel DMSBUS
      const key = `stall_${number}`;
      DMSBUS.set(key, JSON.stringify(stallData));
      
      alert(`‚úÖ Dati posteggio #${number} salvati nel DMSBUS!\nChiave: ${key}`);
      
      // Apri Vetrina Editor in nuova tab con parametri
      const vetrinaUrl = `./vetrina_editor.html?stall=${number}&lat=${lat}&lng=${lng}`;
      window.open(vetrinaUrl, '_blank');
    }
    
    // Sincronizzazione controlli larghezza
    function updateWidthControls(value) {
      slotWidth = parseFloat(value);
      document.getElementById('slot-width').value = slotWidth;
      document.getElementById('slot-width-input').value = slotWidth.toFixed(1);
      document.getElementById('slot-width-value').textContent = slotWidth.toFixed(1) + 'm';
      if (tempSlot) updateTempSlot();
    }
    
    document.getElementById('slot-width').addEventListener('input', (e) => updateWidthControls(e.target.value));
    document.getElementById('slot-width-input').addEventListener('input', (e) => updateWidthControls(e.target.value));
    document.getElementById('btn-width-plus').addEventListener('click', () => updateWidthControls(Math.min(50, slotWidth + 0.1)));
    document.getElementById('btn-width-minus').addEventListener('click', () => updateWidthControls(Math.max(1, slotWidth - 0.1)));
    
    // Sincronizzazione controlli altezza
    function updateHeightControls(value) {
      slotHeight = parseFloat(value);
      document.getElementById('slot-height').value = slotHeight;
      document.getElementById('slot-height-input').value = slotHeight.toFixed(1);
      document.getElementById('slot-height-value').textContent = slotHeight.toFixed(1) + 'm';
      if (tempSlot) updateTempSlot();
    }
    
    document.getElementById('slot-height').addEventListener('input', (e) => updateHeightControls(e.target.value));
    document.getElementById('slot-height-input').addEventListener('input', (e) => updateHeightControls(e.target.value));
    document.getElementById('btn-height-plus').addEventListener('click', () => updateHeightControls(Math.min(50, slotHeight + 0.1)));
    document.getElementById('btn-height-minus').addEventListener('click', () => updateHeightControls(Math.max(1, slotHeight - 0.1)));
    
    // Sincronizzazione controlli rotazione
    function updateRotationControls(value) {
      slotRotation = parseFloat(value) % 360;
      document.getElementById('slot-rotation').value = slotRotation;
      document.getElementById('slot-rotation-input').value = slotRotation.toFixed(1);
      document.getElementById('slot-rotation-value').textContent = slotRotation.toFixed(1) + '¬∞';
      if (tempSlot) updateTempSlot();
    }
    
    document.getElementById('slot-rotation').addEventListener('input', (e) => updateRotationControls(e.target.value));
    document.getElementById('slot-rotation-input').addEventListener('input', (e) => updateRotationControls(e.target.value));
    document.getElementById('btn-slot-rotation-plus').addEventListener('click', () => updateRotationControls(Math.min(360, slotRotation + 1)));
    document.getElementById('btn-slot-rotation-minus').addEventListener('click', () => updateRotationControls(Math.max(0, slotRotation - 1)));
    
    // Funzione per aggiornare posteggio temporaneo
    function updateTempSlot() {
      if (!tempSlot) {
        console.log('‚ö†Ô∏è updateTempSlot: tempSlot √® null');
        return;
      }
      
      const number = document.getElementById('slot-number').value;
      
      console.log(`üîÑ updateTempSlot: width=${slotWidth}m, height=${slotHeight}m, rotation=${slotRotation}¬∞`);
      
      // Salva posizione corrente (centro del polygon)
      const currentCenter = { lat: tempSlot.lat, lng: tempSlot.lng };
      
      // RIMUOVI polygon e tooltip vecchi
      tempSlot.polygon.remove();
      if (tempSlot.tooltip) {
        map.closeTooltip(tempSlot.tooltip);
      }
      
      // Calcola nuovi corner geografici (con rotazione)
      const corners = calculateSlotBounds(currentCenter, slotWidth, slotHeight, slotRotation);
      
      // RICREA polygon con nuove dimensioni e rotazione
      const newPolygon = L.polygon(corners, {
        color: '#ff8800',
        weight: 2,
        fillColor: '#ffa500',
        fillOpacity: 0.9,
        className: 'temp-slot',
        pane: 'slotsPane'
      }).addTo(map);
      
      // RICREA tooltip con numero
      const newTooltip = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'slot-number-label',
        offset: [0, 0]
      })
      .setContent(`<div style="font-weight: bold; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">${number}</div>`)
      .setLatLng(currentCenter);
      
      newPolygon.bindTooltip(newTooltip).openTooltip();
      
      console.log(`üîÑ Polygon geografico aggiornato: ${slotWidth}m √ó ${slotHeight}m, rotation=${slotRotation}¬∞`);
      
      // Aggiorna riferimento
      tempSlot.polygon = newPolygon;
      tempSlot.tooltip = newTooltip;
      tempSlot.width = slotWidth;
      tempSlot.height = slotHeight;
      tempSlot.rotation = slotRotation;
      tempSlot.number = parseInt(number);
    }
    
    // Modalit√† aggiungi posteggio
    document.getElementById('btn-add-mode').addEventListener('click', function() {
      // Se c'√® un posteggio temporaneo, rimuovilo
      if (tempSlot) {
        tempSlot.polygon.remove();
        if (tempSlot.tooltip) {
          map.closeTooltip(tempSlot.tooltip);
        }
        tempSlot = null;
        // Pulsante sempre visibile
      }
      
      addMode = !addMode;
      this.textContent = addMode ? 'üõë Disattiva Modalit√†' : 'üìç Modalit√† Aggiungi Posteggio';
      this.className = addMode ? 'danger' : 'active';
      map.getContainer().style.cursor = addMode ? 'crosshair' : '';
    });
    
    // Click sulla mappa per aggiungere posteggio/marker/area
    // IMPORTANTE: Rimuovi vecchi listener per evitare duplicati!
    map.off('click');
    map.on('click', (e) => {
      console.log(`üó∫Ô∏è MAP CLICK! addMode=${addMode}, tempSlot=${tempSlot ? 'EXISTS' : 'null'}`);
      
      // Gestione posteggi
      if (addMode && !tempSlot) {
      const keepDim = document.getElementById('keep-dimensions').checked;
      const number = document.getElementById('slot-number').value;
      
      // Crea POLYGON geografico TEMPORANEO (arancione) che scala con zoom e ruota
      console.log(`üü° Nuovo posteggio: ${slotWidth}m √ó ${slotHeight}m, rotation=${slotRotation}¬∞`);
      
      // Calcola corner geografici da dimensioni in metri (con rotazione)
      const corners = calculateSlotBounds(e.latlng, slotWidth, slotHeight, slotRotation);
      
      // Crea polygon geografico (4 corner ruotati)
      const polygon = L.polygon(corners, {
        color: '#ff8800',
        weight: 2,
        fillColor: '#ffa500',
        fillOpacity: 0.9,
        className: 'temp-slot',
        pane: 'slotsPane'
      }).addTo(map);
      
      // Aggiungi tooltip permanente con numero al centro
      const center = polygon.getBounds().getCenter();
      const tooltip = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'slot-number-label',
        offset: [0, 0]
      })
      .setContent(`<div style="font-weight: bold; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">${number}</div>`)
      .setLatLng(center);
      
      polygon.bindTooltip(tooltip).openTooltip();
      
      console.log(`üü° Polygon geografico creato: ${slotWidth}m √ó ${slotHeight}m, rotation=${slotRotation}¬∞`);
      
      tempSlot = {
        number: parseInt(number),
        lat: e.latlng.lat,
        lng: e.latlng.lng,
        width: slotWidth,
        height: slotHeight,
        rotation: slotRotation,
        polygon: polygon,
        tooltip: tooltip
      };
      
      // Aggiorna font-size tooltip
      setTimeout(() => {
        updateTooltipFontSize();
      }, 100);
      
      // Implementa dragging manuale per polygon
      let isDragging = false;
      let dragStartLatLng = null;
      
      polygon.on('mousedown', (e) => {
        isDragging = true;
        dragStartLatLng = e.latlng;
        map.dragging.disable(); // Disabilita drag mappa
        L.DomEvent.stopPropagation(e); // Evita propagazione
      });
      
      map.on('mousemove', (e) => {
        if (isDragging && tempSlot) {
          // Calcola offset
          const dLat = e.latlng.lat - dragStartLatLng.lat;
          const dLng = e.latlng.lng - dragStartLatLng.lng;
          
          // Aggiorna posizione centro
          tempSlot.lat += dLat;
          tempSlot.lng += dLng;
          dragStartLatLng = e.latlng;
          
          // Ricalcola corner
          const newCenter = { lat: tempSlot.lat, lng: tempSlot.lng };
          const newCorners = calculateSlotBounds(newCenter, tempSlot.width, tempSlot.height, tempSlot.rotation);
          
          // Aggiorna polygon
          tempSlot.polygon.setLatLngs(newCorners);
          
          // Aggiorna tooltip
          tempSlot.tooltip.setLatLng(newCenter);
        }
      });
      
      map.on('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          map.dragging.enable(); // Riabilita drag mappa
        }
      });
      
      // Mostra pulsante Fissa
      // Pulsante sempre visibile
      
      DMSConsole.log(`üü° Posteggio temporaneo ${number} - regola e click Fissa`);
        return; // Evita altri handler
      }
      
      // Gestione marker
      if (markerMode) {
        addCustomMarker(e.latlng);
        return;
      }
      
      // Gestione aree
      if (areaDrawingMode) {
        addAreaVertex(e.latlng);
        return;
      }
    });
    
    // Pulsante Fissa Posteggio
    document.getElementById('btn-confirm-slot').addEventListener('click', () => {
      if (!tempSlot) return;
      
      console.log(`üü¢ Fissa posteggio #${tempSlot.number}: ${tempSlot.width}m √ó ${tempSlot.height}m, rotation=${tempSlot.rotation}¬∞`);
      
      // Salva posizione corrente (centro)
      const currentCenter = { lat: tempSlot.lat, lng: tempSlot.lng };
      
      // RIMUOVI polygon e tooltip arancioni
      tempSlot.polygon.remove();
      if (tempSlot.tooltip) {
        map.closeTooltip(tempSlot.tooltip);
      }
      
      // Calcola corner geografici (con rotazione)
      const corners = calculateSlotBounds(currentCenter, tempSlot.width, tempSlot.height, tempSlot.rotation);
      
      // CREA polygon VERDE fisso
      const greenPolygon = L.polygon(corners, {
        color: '#4CAF50',
        weight: 2,
        fillColor: '#4CAF50',
        fillOpacity: 0.9,
        className: 'fixed-slot',
        pane: 'slotsPane'
      }).addTo(map);
      
      // Aggiungi tooltip permanente con numero
      const greenTooltip = L.tooltip({
        permanent: true,
        direction: 'center',
        className: 'slot-number-label',
        offset: [0, 0]
      })
      .setContent(`<div style="font-weight: bold; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.8);">${tempSlot.number}</div>`)
      .setLatLng(currentCenter);
      
      greenPolygon.bindTooltip(greenTooltip).openTooltip();
      
      // Aggiungi popup con informazioni complete
      const popupContent = `
        <div style="font-family: sans-serif; min-width: 200px;">
          <h3 style="margin: 0 0 10px 0; color: #4CAF50;">üÖøÔ∏è Posteggio #${tempSlot.number}</h3>
          <p style="margin: 5px 0;"><strong>üìè Dimensioni:</strong> ${tempSlot.width.toFixed(1)}m √ó ${tempSlot.height.toFixed(1)}m</p>
          <p style="margin: 5px 0;"><strong>üîÑ Rotazione:</strong> ${tempSlot.rotation.toFixed(1)}¬∞</p>
          <p style="margin: 5px 0;"><strong>üìç Coordinate:</strong></p>
          <p style="margin: 0 0 10px 15px; font-size: 11px; color: #666;">
            Lat: ${currentCenter.lat.toFixed(8)}<br>
            Lng: ${currentCenter.lng.toFixed(8)}
          </p>
          <button onclick="openVetrinaEditor(${tempSlot.number}, ${currentCenter.lat}, ${currentCenter.lng}, ${tempSlot.width}, ${tempSlot.height}, ${tempSlot.rotation})" 
                  style="width: 100%; padding: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
            üè™ Vai a Vetrina Editor
          </button>
        </div>
      `;
      greenPolygon.bindPopup(popupContent);
      
      console.log(`‚úÖ Polygon verde #${tempSlot.number} fissato con rotazione ${tempSlot.rotation}¬∞`);
      
      // Aggiorna riferimenti
      tempSlot.polygon = greenPolygon;
      tempSlot.tooltip = greenTooltip;
      
      // Aggiungi a lista
      slots.push(tempSlot);
      
      // Incrementa numero per prossimo posteggio
      const nextNumber = tempSlot.number + 1;
      document.getElementById('slot-number').value = nextNumber;
      
      DMSConsole.log(`‚úÖ Posteggio ${tempSlot.number} fissato`);
      
      // Reset
      tempSlot = null;
      // Pulsante sempre visibile
      
      updateSlotList();
      
      // Aggiorna font-size tooltip
      setTimeout(() => {
        updateTooltipFontSize();
      }, 100);
    });
    
    // Pulsante Salva Posizione Posteggi
    document.getElementById('btn-save-slots-position').addEventListener('click', () => {
      if (slots.length === 0) {
        alert('‚ö†Ô∏è Nessun posteggio da salvare!');
        return;
      }
      
      try {
        // Prepara dati da salvare (solo le propriet√† necessarie)
        const slotsData = slots.map(slot => ({
          number: slot.number,
          lat: slot.lat,
          lng: slot.lng,
          width: slot.width,
          height: slot.height,
          rotation: slot.rotation
        }));
        
        // Salva in localStorage
        localStorage.setItem('slots_positions', JSON.stringify(slotsData));
        
        console.log(`üíæ ${slots.length} posteggi salvati in localStorage`);
        
        // Mostra feedback
        const status = document.getElementById('slots-save-status');
        status.textContent = `‚úÖ ${slots.length} posteggi salvati!`;
        status.style.display = 'block';
        setTimeout(() => {
          status.style.display = 'none';
        }, 3000);
      } catch (err) {
        console.error('‚ùå Errore salvataggio localStorage:', err);
        alert('‚ùå Errore durante il salvataggio!');
      }
    });
    
    // Aggiorna lista posteggi
    function updateSlotList() {
      const list = document.getElementById('slot-list');
      const count = document.getElementById('slot-count');
      const total = document.getElementById('total-slots');
      
      count.textContent = `${slots.length} posteggi aggiunti`;
      total.textContent = slots.length;
      
      if (slots.length === 0) {
        list.innerHTML = '<div style="opacity: 0.6;">Nessun posteggio</div>';
        return;
      }
      
      list.innerHTML = slots.map(slot => `
        <div class="slot-item">
          <span>Posteggio ${slot.number} (${slot.width}m √ó ${slot.height}m)</span>
          <button onclick="removeSlot(${slot.number})">‚ùå</button>
        </div>
      `).join('');
    }
    
    // Rimuovi posteggio
    window.removeSlot = function(number) {
      const index = slots.findIndex(s => s.number === number);
      if (index !== -1) {
        const slot = slots[index];
        map.removeLayer(slot.polygon);
        if (slot.tooltip) {
          map.closeTooltip(slot.tooltip);
        }
        slots.splice(index, 1);
        updateSlotList();
        DMSConsole.log(`üóëÔ∏è Posteggio ${number} rimosso`);
      }
    };
    
    // Cancella tutti
    document.getElementById('btn-clear-all').addEventListener('click', async () => {
      if (!confirm('‚ö†Ô∏è Cancellare tutti i posteggi?')) return;
      
      slots.forEach(slot => {
        map.removeLayer(slot.polygon);
        if (slot.tooltip) {
          map.closeTooltip(slot.tooltip);
        }
      });
      slots = [];
      slotCounter = 1;
      updateSlotList();
      
      // Salva nel BUS (posteggi vuoti)
      try {
        const emptyStalls = {
          type: 'FeatureCollection',
          features: []
        };
        await DMSBUS.set('stalls_geojson', JSON.stringify(emptyStalls));
        document.getElementById('export-status').textContent = `‚úÖ Posteggi cancellati e salvati nel Bus!`;
        DMSConsole.log('üóëÔ∏è Tutti i posteggi cancellati e salvati nel BUS');
      } catch (err) {
        console.error('‚ùå Errore salvataggio cancellazione:', err);
      }
    });
    
    // ===== MARKER PERSONALIZZABILI =====
    
    // Pulsante Aggiungi Marker
    document.getElementById('btn-add-marker').addEventListener('click', function() {
      // Disattiva altre modalit√†
      if (addMode) {
        addMode = false;
        document.getElementById('btn-add-mode').textContent = 'üìç Modalit√† Aggiungi Posteggio';
        document.getElementById('btn-add-mode').className = 'active';
      }
      if (areaDrawingMode) {
        cancelAreaDrawing();
      }
      
      markerMode = !markerMode;
      this.textContent = markerMode ? 'üõë Disattiva Modalit√†' : 'üìç Aggiungi Marker';
      this.className = markerMode ? 'danger' : 'active';
      map.getContainer().style.cursor = markerMode ? 'crosshair' : '';
      
      if (markerMode) {
        DMSConsole.log('‚úÖ Modalit√† marker attiva - click sulla mappa');
      } else {
        DMSConsole.log('‚ùå Modalit√† marker disattivata');
      }
    });
    

    
    // Funzione per aggiungere marker personalizzabile
    function addCustomMarker(latlng) {
      const markerData = {
        number: markerCounter,
        lat: latlng.lat,
        lng: latlng.lng,
        letter: 'M',
        size: 30,
        bgColor: '#4CAF50',
        textColor: '#FFFFFF',
        borderColor: '#2E7D32',
        borderWidth: 3,
        name: '',
        type: 'shop',
        description: '',
        extra: {},
        status: 'active'
      };
      
      // Crea marker Leaflet
      const marker = L.marker(latlng, {
        icon: L.divIcon({
          className: 'custom-marker',
          html: `<div style="
            width: ${markerData.size}px; 
            height: ${markerData.size}px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            background: ${markerData.bgColor}; 
            border: ${markerData.borderWidth}px solid ${markerData.borderColor}; 
            border-radius: 4px; 
            font-weight: bold; 
            font-size: ${markerData.size * 0.5}px; 
            color: ${markerData.textColor};
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          ">${markerData.letter}</div>`,
          iconSize: [markerData.size, markerData.size],
          iconAnchor: [markerData.size / 2, markerData.size / 2]
        }),
        draggable: true
      }).addTo(map);
      
      markerData.marker = marker;
      
      // Popup configurazione
      const popupContent = createMarkerConfigForm(markerData);
      marker.bindPopup(popupContent, { maxWidth: 400, minWidth: 300 }).openPopup();
      
      // Salva marker
      markers.push(markerData);
      markerCounter++;
      
      updateMarkerList();
      DMSConsole.log(`‚úÖ Marker #${markerData.number} aggiunto`);
    }
    
    // Form configurazione marker
    function createMarkerConfigForm(marker) {
      return `
        <div style="min-width: 300px;">
          <h3 style="margin: 0 0 12px 0;">üìç Marker #${marker.number}</h3>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Lettera/Simbolo:</label>
              <input type="text" id="marker-letter-${marker.number}" value="${marker.letter}" maxlength="2" style="width: 100%; padding: 6px; font-size: 14px; text-align: center;" />
            </div>
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Dimensione (px):</label>
              <input type="number" id="marker-size-${marker.number}" value="${marker.size}" min="20" max="60" style="width: 100%; padding: 6px;" />
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Colore Sfondo:</label>
              <input type="color" id="marker-bgcolor-${marker.number}" value="${marker.bgColor}" style="width: 100%; height: 36px; cursor: pointer;" />
            </div>
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Colore Testo:</label>
              <input type="color" id="marker-textcolor-${marker.number}" value="${marker.textColor}" style="width: 100%; height: 36px; cursor: pointer;" />
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Colore Bordo:</label>
              <input type="color" id="marker-bordercolor-${marker.number}" value="${marker.borderColor}" style="width: 100%; height: 36px; cursor: pointer;" />
            </div>
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Spessore Bordo:</label>
              <input type="number" id="marker-borderwidth-${marker.number}" value="${marker.borderWidth}" min="1" max="10" style="width: 100%; padding: 6px;" />
            </div>
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Nome:</label>
            <input type="text" id="marker-name-${marker.number}" value="${marker.name}" style="width: 100%; padding: 6px;" placeholder="Es: Pizzeria Da Mario" />
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Tipo:</label>
            <select id="marker-type-${marker.number}" style="width: 100%; padding: 6px;">
              <option value="shop" ${marker.type === 'shop' ? 'selected' : ''}>üè™ Negozio</option>
              <option value="service" ${marker.type === 'service' ? 'selected' : ''}>üöª Servizio</option>
              <option value="poi" ${marker.type === 'poi' ? 'selected' : ''}>üìç Punto di Interesse</option>
              <option value="parking" ${marker.type === 'parking' ? 'selected' : ''}>üÖøÔ∏è Parcheggio</option>
              <option value="info" ${marker.type === 'info' ? 'selected' : ''}>‚ÑπÔ∏è Info Point</option>
              <option value="other" ${marker.type === 'other' ? 'selected' : ''}>üìå Altro</option>
            </select>
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Descrizione:</label>
            <textarea id="marker-desc-${marker.number}" style="width: 100%; padding: 6px; min-height: 60px; resize: vertical;" placeholder="Descrizione...">${marker.description}</textarea>
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Status:</label>
            <select id="marker-status-${marker.number}" style="width: 100%; padding: 6px;">
              <option value="active" ${marker.status === 'active' ? 'selected' : ''}>üü¢ Attivo</option>
              <option value="inactive" ${marker.status === 'inactive' ? 'selected' : ''}>üî¥ Inattivo</option>
              <option value="maintenance" ${marker.status === 'maintenance' ? 'selected' : ''}>üü° Manutenzione</option>
            </select>
          </div>
          
          <button onclick="updateMarkerFromForm(${marker.number})" style="width: 100%; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">‚úÖ Salva Modifiche</button>
          
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #ddd; font-size: 11px; color: #666;">
            <strong>Coordinate:</strong><br>
            Lat: ${marker.lat.toFixed(8)}<br>
            Lng: ${marker.lng.toFixed(8)}
          </div>
        </div>
      `;
    }
    
    // Aggiorna marker da form
    window.updateMarkerFromForm = function(number) {
      const marker = markers.find(m => m.number === number);
      if (!marker) return;
      
      // Leggi valori dal form
      marker.letter = document.getElementById(`marker-letter-${number}`).value || 'M';
      marker.size = parseInt(document.getElementById(`marker-size-${number}`).value) || 30;
      marker.bgColor = document.getElementById(`marker-bgcolor-${number}`).value;
      marker.textColor = document.getElementById(`marker-textcolor-${number}`).value;
      marker.borderColor = document.getElementById(`marker-bordercolor-${number}`).value;
      marker.borderWidth = parseInt(document.getElementById(`marker-borderwidth-${number}`).value) || 3;
      marker.name = document.getElementById(`marker-name-${number}`).value;
      marker.type = document.getElementById(`marker-type-${number}`).value;
      marker.description = document.getElementById(`marker-desc-${number}`).value;
      marker.status = document.getElementById(`marker-status-${number}`).value;
      
      // Aggiorna posizione
      const pos = marker.marker.getLatLng();
      marker.lat = pos.lat;
      marker.lng = pos.lng;
      
      // Ricrea marker con nuove propriet√†
      map.removeLayer(marker.marker);
      marker.marker = L.marker([marker.lat, marker.lng], {
        icon: L.divIcon({
          className: 'custom-marker',
          html: `<div style="
            width: ${marker.size}px; 
            height: ${marker.size}px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            background: ${marker.bgColor}; 
            border: ${marker.borderWidth}px solid ${marker.borderColor}; 
            border-radius: 4px; 
            font-weight: bold; 
            font-size: ${marker.size * 0.5}px; 
            color: ${marker.textColor};
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          ">${marker.letter}</div>`,
          iconSize: [marker.size, marker.size],
          iconAnchor: [marker.size / 2, marker.size / 2]
        }),
        draggable: false
      }).addTo(map);
      
      // Popup finale
      const statusEmoji = {
        active: 'üü¢',
        inactive: 'üî¥',
        maintenance: 'üü°'
      };
      const finalPopup = `
        <div style="min-width: 200px;">
          <h3>${marker.letter} ${marker.name || 'Marker #' + marker.number}</h3>
          <p><strong>Tipo:</strong> ${marker.type}</p>
          <p>${marker.description || ''}</p>
          <p><strong>Status:</strong> ${statusEmoji[marker.status]} ${marker.status}</p>
          <p style="font-size: 11px; color: #666; margin-top: 8px;">
            Lat: ${marker.lat.toFixed(8)}<br>
            Lng: ${marker.lng.toFixed(8)}
          </p>
        </div>
      `;
      marker.marker.bindPopup(finalPopup);
      
      updateMarkerList();
      DMSConsole.log(`‚úÖ Marker #${number} aggiornato`);
    };
    
    // Aggiorna lista marker
    function updateMarkerList() {
      const list = document.getElementById('marker-list');
      const count = document.getElementById('marker-count');
      
      if (markers.length === 0) {
        list.innerHTML = '<div style="opacity: 0.6;">Nessun marker</div>';
      } else {
        list.innerHTML = markers.map(m => `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); margin-bottom: 4px; border-radius: 4px;">
            <span>${m.letter} ${m.name || 'Marker #' + m.number}</span>
            <button onclick="removeMarker(${m.number})" style="background: #f44336; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer;">‚ùå</button>
          </div>
        `).join('');
      }
      
      count.textContent = `${markers.length} marker aggiunti`;
    }
    
    // Rimuovi marker
    window.removeMarker = function(number) {
      const marker = markers.find(m => m.number === number);
      if (marker) {
        map.removeLayer(marker.marker);
        markers = markers.filter(m => m.number !== number);
        updateMarkerList();
        DMSConsole.log(`üóëÔ∏è Marker ${number} rimosso`);
      }
    };
    
    // ===== AREE PERSONALIZZABILI =====
    
    // Pulsante Disegna Area
    document.getElementById('btn-draw-area').addEventListener('click', function() {
      if (areaDrawingMode) return;
      
      // Disattiva altre modalit√†
      if (addMode) {
        addMode = false;
        document.getElementById('btn-add-mode').textContent = 'üìç Modalit√† Aggiungi Posteggio';
        document.getElementById('btn-add-mode').className = 'active';
      }
      if (markerMode) {
        markerMode = false;
        document.getElementById('btn-add-marker').textContent = 'üìç Aggiungi Marker';
        document.getElementById('btn-add-marker').className = 'active';
      }
      
      startAreaDrawing();
    });
    
    // Inizia disegno area
    function startAreaDrawing() {
      areaDrawingMode = true;
      currentAreaVertices = [];
      currentAreaMarkers = [];
      
      document.getElementById('btn-draw-area').style.display = 'none';
      document.getElementById('btn-finish-area').style.display = 'block';
      document.getElementById('btn-cancel-area').style.display = 'block';
      document.getElementById('area-drawing-info').style.display = 'block';
      
      map.getContainer().style.cursor = 'crosshair';
      DMSConsole.log('‚úÖ Modalit√† disegno area attiva - click per aggiungere vertici, doppio-click per chiudere');
    }
    
    // Aggiungi vertice area
    function addAreaVertex(latlng) {
      currentAreaVertices.push(latlng);
      
      // Marker vertice temporaneo
      const vertexMarker = L.circleMarker(latlng, {
        radius: 5,
        color: '#2196F3',
        fillColor: '#2196F3',
        fillOpacity: 0.8
      }).addTo(map);
      currentAreaMarkers.push(vertexMarker);
      
      // Aggiorna polyline
      if (currentAreaPolyline) {
        map.removeLayer(currentAreaPolyline);
      }
      
      if (currentAreaVertices.length > 1) {
        currentAreaPolyline = L.polyline(currentAreaVertices, {
          color: '#2196F3',
          weight: 2,
          dashArray: '5, 5'
        }).addTo(map);
      }
      
      DMSConsole.log(`üîµ Vertice ${currentAreaVertices.length} aggiunto`);
    }
    
    // Doppio click per completare area
    map.on('dblclick', (e) => {
      if (!areaDrawingMode || currentAreaVertices.length < 3) return;
      
      L.DomEvent.stopPropagation(e);
      finishAreaDrawing();
    });
    
    // Pulsante Completa Area
    document.getElementById('btn-finish-area').addEventListener('click', finishAreaDrawing);
    
    // Completa disegno area
    function finishAreaDrawing() {
      if (currentAreaVertices.length < 3) {
        alert('‚ö†Ô∏è Servono almeno 3 vertici per creare un\'area!');
        return;
      }
      
      // Rimuovi marker temporanei
      currentAreaMarkers.forEach(m => map.removeLayer(m));
      if (currentAreaPolyline) map.removeLayer(currentAreaPolyline);
      
      // Crea area
      const areaData = {
        number: areaCounter,
        coordinates: currentAreaVertices.map(v => [v.lat, v.lng]),
        name: '',
        type: 'market',
        fillColor: '#4CAF50',
        fillOpacity: 0.3,
        borderColor: '#2E7D32',
        borderWidth: 3,
        description: ''
      };
      
      const polygon = L.polygon(currentAreaVertices, {
        color: areaData.borderColor,
        weight: areaData.borderWidth,
        fillColor: areaData.fillColor,
        fillOpacity: areaData.fillOpacity
      }).addTo(map);
      
      areaData.polygon = polygon;
      
      // Popup configurazione
      const popupContent = createAreaConfigForm(areaData);
      polygon.bindPopup(popupContent, { maxWidth: 400, minWidth: 300 }).openPopup();
      
      // Salva area
      areas.push(areaData);
      areaCounter++;
      
      // Reset modalit√†
      areaDrawingMode = false;
      currentAreaVertices = [];
      currentAreaMarkers = [];
      currentAreaPolyline = null;
      
      document.getElementById('btn-draw-area').style.display = 'block';
      document.getElementById('btn-finish-area').style.display = 'none';
      document.getElementById('btn-cancel-area').style.display = 'none';
      document.getElementById('area-drawing-info').style.display = 'none';
      map.getContainer().style.cursor = '';
      
      updateAreaList();
      DMSConsole.log(`‚úÖ Area #${areaData.number} creata con ${areaData.coordinates.length} vertici`);
    }
    
    // Pulsante Annulla Area
    document.getElementById('btn-cancel-area').addEventListener('click', cancelAreaDrawing);
    
    // Annulla disegno area
    function cancelAreaDrawing() {
      currentAreaMarkers.forEach(m => map.removeLayer(m));
      if (currentAreaPolyline) map.removeLayer(currentAreaPolyline);
      
      areaDrawingMode = false;
      currentAreaVertices = [];
      currentAreaMarkers = [];
      currentAreaPolyline = null;
      
      document.getElementById('btn-draw-area').style.display = 'block';
      document.getElementById('btn-finish-area').style.display = 'none';
      document.getElementById('btn-cancel-area').style.display = 'none';
      document.getElementById('area-drawing-info').style.display = 'none';
      map.getContainer().style.cursor = '';
      
      DMSConsole.log('‚ùå Disegno area annullato');
    }
    
    // Form configurazione area
    function createAreaConfigForm(area) {
      return `
        <div style="min-width: 300px;">
          <h3 style="margin: 0 0 12px 0;">üìê Area #${area.number}</h3>
          
          <div style="margin-bottom: 12px;">
            <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Nome:</label>
            <input type="text" id="area-name-${area.number}" value="${area.name}" style="width: 100%; padding: 6px;" placeholder="Es: Area Mercato" />
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Tipo:</label>
            <select id="area-type-${area.number}" style="width: 100%; padding: 6px;">
              <option value="market" ${area.type === 'market' ? 'selected' : ''}>üè™ Mercato</option>
              <option value="hub" ${area.type === 'hub' ? 'selected' : ''}>üöå Hub</option>
              <option value="parking" ${area.type === 'parking' ? 'selected' : ''}>üÖøÔ∏è Parcheggio</option>
              <option value="green" ${area.type === 'green' ? 'selected' : ''}>üå≥ Area Verde</option>
              <option value="restricted" ${area.type === 'restricted' ? 'selected' : ''}>üö´ Zona Riservata</option>
              <option value="other" ${area.type === 'other' ? 'selected' : ''}>üìç Altro</option>
            </select>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Colore Riempimento:</label>
              <input type="color" id="area-fillcolor-${area.number}" value="${area.fillColor}" style="width: 100%; height: 36px; cursor: pointer;" />
            </div>
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Opacit√† (%):</label>
              <input type="number" id="area-opacity-${area.number}" value="${area.fillOpacity * 100}" min="0" max="100" style="width: 100%; padding: 6px;" />
            </div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Colore Bordo:</label>
              <input type="color" id="area-bordercolor-${area.number}" value="${area.borderColor}" style="width: 100%; height: 36px; cursor: pointer;" />
            </div>
            <div>
              <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Spessore Bordo:</label>
              <input type="number" id="area-borderwidth-${area.number}" value="${area.borderWidth}" min="1" max="10" style="width: 100%; padding: 6px;" />
            </div>
          </div>
          
          <div style="margin-bottom: 12px;">
            <label style="font-weight: bold; display: block; margin-bottom: 4px; font-size: 12px;">Descrizione:</label>
            <textarea id="area-desc-${area.number}" style="width: 100%; padding: 6px; min-height: 60px; resize: vertical;" placeholder="Descrizione area...">${area.description}</textarea>
          </div>
          
          <button onclick="updateAreaFromForm(${area.number})" style="width: 100%; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">‚úÖ Salva Modifiche</button>
          
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #ddd; font-size: 11px; color: #666;">
            <strong>Vertici:</strong> ${area.coordinates.length}<br>
            <strong>Area:</strong> ~${calculatePolygonArea(area.coordinates).toFixed(0)} m¬≤
          </div>
        </div>
      `;
    }
    
    // Aggiorna area da form
    window.updateAreaFromForm = function(number) {
      const area = areas.find(a => a.number === number);
      if (!area) return;
      
      // Leggi valori dal form
      area.name = document.getElementById(`area-name-${number}`).value;
      area.type = document.getElementById(`area-type-${number}`).value;
      area.fillColor = document.getElementById(`area-fillcolor-${number}`).value;
      area.fillOpacity = parseInt(document.getElementById(`area-opacity-${number}`).value) / 100;
      area.borderColor = document.getElementById(`area-bordercolor-${number}`).value;
      area.borderWidth = parseInt(document.getElementById(`area-borderwidth-${number}`).value) || 3;
      area.description = document.getElementById(`area-desc-${number}`).value;
      
      // Ricrea poligono con nuove propriet√†
      map.removeLayer(area.polygon);
      area.polygon = L.polygon(area.coordinates.map(c => L.latLng(c[0], c[1])), {
        color: area.borderColor,
        weight: area.borderWidth,
        fillColor: area.fillColor,
        fillOpacity: area.fillOpacity
      }).addTo(map);
      
      // Popup finale
      const finalPopup = `
        <div style="min-width: 200px;">
          <h3>üìê ${area.name || 'Area #' + area.number}</h3>
          <p><strong>Tipo:</strong> ${area.type}</p>
          <p>${area.description || ''}</p>
          <p><strong>Vertici:</strong> ${area.coordinates.length}</p>
          <p><strong>Area:</strong> ~${calculatePolygonArea(area.coordinates).toFixed(0)} m¬≤</p>
        </div>
      `;
      area.polygon.bindPopup(finalPopup);
      
      updateAreaList();
      DMSConsole.log(`‚úÖ Area #${number} aggiornata`);
    };
    
    // Aggiorna lista aree
    function updateAreaList() {
      const list = document.getElementById('area-list');
      const count = document.getElementById('area-count');
      
      if (areas.length === 0) {
        list.innerHTML = '<div style="opacity: 0.6;">Nessuna area</div>';
      } else {
        list.innerHTML = areas.map(a => `
          <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); margin-bottom: 4px; border-radius: 4px;">
            <span>üìê ${a.name || 'Area #' + a.number} (${a.coordinates.length} vertici)</span>
            <button onclick="removeArea(${a.number})" style="background: #f44336; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer;">‚ùå</button>
          </div>
        `).join('');
      }
      
      count.textContent = `${areas.length} aree aggiunte`;
    }
    
    // Rimuovi area
    window.removeArea = function(number) {
      const area = areas.find(a => a.number === number);
      if (area) {
        map.removeLayer(area.polygon);
        areas = areas.filter(a => a.number !== number);
        updateAreaList();
        DMSConsole.log(`üóëÔ∏è Area ${number} rimossa`);
      }
    };
    
    
    // Esporta GeoJSON
    document.getElementById('btn-export-json').addEventListener('click', () => {
      if (slots.length === 0) {
        alert('‚ö†Ô∏è Aggiungi almeno un posteggio prima di esportare!');
        return;
      }
      
      if (!plantBounds) {
        alert('‚ö†Ô∏è Carica e posiziona la pianta prima di esportare!');
        return;
      }
      
      // Cattura 4 corner della pianta
      const corners = [
        [plantBounds.getNorthWest().lat, plantBounds.getNorthWest().lng],
        [plantBounds.getNorthEast().lat, plantBounds.getNorthEast().lng],
        [plantBounds.getSouthEast().lat, plantBounds.getSouthEast().lng],
        [plantBounds.getSouthWest().lat, plantBounds.getSouthWest().lng]
      ];
      
      // Crea GeoJSON posteggi
      const stallsGeoJSON = {
        type: 'FeatureCollection',
        features: slots.map(slot => ({
          type: 'Feature',
          geometry: {
            type: 'Point',
            coordinates: [slot.lng, slot.lat]
          },
          properties: {
            number: slot.number,
            orientation: slot.rotation,
            kind: 'slot',
            status: 'free',
            dimensions: `${slot.width}m √ó ${slot.height}m`
          }
        }))
      };
      
      // Crea GeoJSON marker personalizzabili
      const markersGeoJSON = {
        type: 'FeatureCollection',
        features: markers.map(m => ({
          type: 'Feature',
          geometry: {
            type: 'Point',
            coordinates: [m.lng, m.lat]
          },
          properties: {
            number: m.number,
            letter: m.letter,
            size: m.size,
            bgColor: m.bgColor,
            textColor: m.textColor,
            borderColor: m.borderColor,
            borderWidth: m.borderWidth,
            name: m.name,
            type: m.type,
            description: m.description,
            extra: m.extra,
            status: m.status,
            kind: 'marker'
          }
        }))
      };
      
      // Crea GeoJSON aree personalizzabili
      const areasGeoJSON = {
        type: 'FeatureCollection',
        features: areas.map(a => ({
          type: 'Feature',
          geometry: {
            type: 'Polygon',
            coordinates: [a.coordinates.map(c => [c[1], c[0]])]
          },
          properties: {
            number: a.number,
            name: a.name,
            type: a.type,
            fillColor: a.fillColor,
            fillOpacity: a.fillOpacity,
            borderColor: a.borderColor,
            borderWidth: a.borderWidth,
            description: a.description,
            kind: 'area'
          }
        }))
      };
      
      // Crea JSON completo
      const exportData = {
        container: corners,
        stalls_geojson: stallsGeoJSON,
        markers_geojson: markersGeoJSON,
        areas_geojson: areasGeoJSON,
        plant_rotation: plantRotation,
        plant_scale: plantScale,
        timestamp: new Date().toISOString()
      };
      
      // Download
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const totalItems = slots.length + markers.length + areas.length;
      a.download = `mercato-esperanto-${totalItems}-items-${new Date().toISOString().split('T')[0]}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      document.getElementById('export-status').textContent = `‚úÖ ${slots.length} posteggi, ${markers.length} marker, ${areas.length} aree esportati!`;
      DMSConsole.log(`‚úÖ JSON esportato con ${slots.length} posteggi e 4 corner`);
    });
    
    // Esporta per Dashboard Admin
    document.getElementById('btn-export-dashboard').addEventListener('click', () => {
      if (slots.length === 0) {
        alert('‚ö†Ô∏è Aggiungi almeno un posteggio prima di esportare!');
        return;
      }
      
      if (!plantBounds) {
        alert('‚ö†Ô∏è Carica e posiziona la pianta prima di esportare!');
        return;
      }
      
      // Calcola centro del mercato (media di tutti i posteggi)
      const avgLat = slots.reduce((sum, s) => sum + s.lat, 0) / slots.length;
      const avgLng = slots.reduce((sum, s) => sum + s.lng, 0) / slots.length;
      
      // Cattura 4 corner della pianta per container
      const corners = [
        [plantBounds.getNorthWest().lat, plantBounds.getNorthWest().lng],
        [plantBounds.getNorthEast().lat, plantBounds.getNorthEast().lng],
        [plantBounds.getSouthEast().lat, plantBounds.getSouthEast().lng],
        [plantBounds.getSouthWest().lat, plantBounds.getSouthWest().lng]
      ];
      
      // Prepara dati nel formato atteso dalla Dashboard Admin
      const dashboardData = {
        container: corners,
        center: {
          lat: avgLat,
          lng: avgLng
        },
        gcp: [], // GCP points (Ground Control Points) - opzionale
        png: {
          url: '', // URL PNG verr√† popolato dopo upload manuale
          metadata: {
            rotation: plantRotation,
            scale: plantScale
          }
        },
        stalls: slots.map(slot => ({
          number: slot.number.toString(),
          lat: slot.lat,
          lng: slot.lng,
          areaMq: parseFloat((slot.width * slot.height).toFixed(2)),
          category: 'alimentare' // Categoria default
        })),
        customMarkers: markers.map(m => ({
          name: m.name || `Marker ${m.number}`,
          type: m.type || 'info',
          lat: m.lat,
          lng: m.lng,
          icon: m.type || 'info',
          color: m.bgColor || '#3b82f6',
          description: m.description || ''
        })),
        customAreas: areas.map(a => ({
          name: a.name || `Area ${a.number}`,
          type: a.type || 'zone',
          geojson: {
            type: 'Polygon',
            coordinates: [a.coordinates.map(c => [c[1], c[0]])]
          },
          color: a.fillColor || '#10b981',
          opacity: a.fillOpacity || 0.3,
          description: a.description || ''
        }))
      };
      
      // Invia JSON automaticamente alla Dashboard Admin via API
      document.getElementById('export-status').textContent = `üîÑ Invio in corso...`;
      
      // Converti nel formato GeoJSON v3 per l'API
      const geojsonData = {
        container: corners,
        stalls_geojson: {
          type: 'FeatureCollection',
          features: slots.map(slot => ({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [slot.lng, slot.lat]
            },
            properties: {
              number: slot.number,
              orientation: slot.rotation || 0,
              kind: 'slot',
              status: 'free',
              dimensions: `${slot.width}m √ó ${slot.height}m`
            }
          }))
        },
        markers_geojson: {
          type: 'FeatureCollection',
          features: markers.map(m => ({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [m.lng, m.lat]
            },
            properties: {
              name: m.name || `Marker ${m.number}`,
              type: m.type || 'info',
              icon: m.type || 'M',
              color: m.bgColor || '#3b82f6',
              description: m.description || ''
            }
          }))
        },
        areas_geojson: {
          type: 'FeatureCollection',
          features: areas.map(a => ({
            type: 'Feature',
            geometry: {
              type: 'Polygon',
              coordinates: [a.coordinates.map(c => [c[1], c[0]])]
            },
            properties: {
              name: a.name || `Area ${a.number}`,
              type: a.type || 'zone',
              color: a.fillColor || '#10b981',
              opacity: a.fillOpacity || 0.3,
              description: a.description || ''
            }
          }))
        },
        plant_rotation: plantRotation,
        plant_scale: plantScale
      };
      
      // Invia via REST API
      DMSConsole.log(`Invio ${slots.length} posteggi, ${markers.length} marker, ${areas.length} aree alla Dashboard Admin...`, 'info');
      
      fetch('https://dmshubapp-hkvujnro.manus.space/api/dmsHub/markets/importAuto', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          slotEditorData: geojsonData
        })
      })
      .then(response => response.json())
      .then(data => {
        console.log('Risposta API:', data);
        if (data.success) {
          DMSConsole.log(`‚úÖ Import completato: ${data.marketName} - ${data.stallsCreated} posteggi, ${data.markersCreated} marker, ${data.areasCreated} aree`, 'success');
          document.getElementById('export-status').textContent = `‚úÖ Importato automaticamente: ${data.stallsCreated} posteggi!`;
          alert(`‚úÖ Import completato con successo!\n\nüìä Dati importati:\n- Mercato: ${data.marketName}\n- ${data.stallsCreated} posteggi\n- ${data.markersCreated} marker\n- ${data.areasCreated} aree\n\nüìç Vai alla Dashboard Admin per vedere il mercato sulla mappa!`);
        } else {
          DMSConsole.log(`‚ùå Import fallito: ${data.error}`, 'error');
          throw new Error(data.error || 'Import fallito');
        }
      })
      .catch(error => {
        console.error('Errore import:', error);
        DMSConsole.log(`‚ùå Errore import: ${error.message}`, 'error');
        document.getElementById('export-status').textContent = `‚ùå Errore: ${error.message}`;
        alert(`‚ùå Errore durante l'import automatico!\n\nüîß Soluzione alternativa:\n1. Scarica il JSON manualmente\n2. Apri Dashboard Admin\n3. Usa "Importa da Slot Editor v3" manuale\n\nErrore: ${error.message}`);
      });
    });
    
    // Import JSON
    document.getElementById('btn-import-json').addEventListener('click', () => {
      document.getElementById('import-json-file').click();
    });
    
    document.getElementById('import-json-file').addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      
      DMSConsole.log(`üì• Caricamento file: ${file.name}`, 'info');
      document.getElementById('import-status').textContent = `üîÑ Caricamento ${file.name}...`;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const jsonData = JSON.parse(e.target.result);
          DMSConsole.log(`‚úÖ JSON parsato: ${JSON.stringify(jsonData).length} caratteri`, 'success');
          
          // Verifica formato JSON - SUPPORTA SIA stalls CHE stalls_geojson
          if (!jsonData.stalls && !jsonData.stalls_geojson && !jsonData.container) {
            throw new Error('Formato JSON non valido: mancano stalls/stalls_geojson o container');
          }
          
          // Reset dati correnti
          // Rimuovi posteggi esistenti dalla mappa
          slots.forEach(slot => {
            if (slot.polygon) {
              map.removeLayer(slot.polygon);
            }
            if (slot.tooltip) {
              map.closeTooltip(slot.tooltip);
            }
          });
          slots = [];
          
          // Rimuovi marker esistenti dalla mappa
          markers.forEach(marker => {
            if (marker.leafletMarker) {
              map.removeLayer(marker.leafletMarker);
            }
          });
          markers = [];
          
          // Rimuovi aree esistenti dalla mappa
          areas.forEach(area => {
            if (area.polygon) {
              map.removeLayer(area.polygon);
            }
          });
          areas = [];
          
          DMSConsole.log('üßπ Dati precedenti cancellati', 'info');
          
          // Carica container (pianta)
          if (jsonData.container && jsonData.container.length === 4) {
            const [[lat1, lng1], [lat2, lng2], [lat3, lng3], [lat4, lng4]] = jsonData.container;
            plantBounds = L.latLngBounds(
              [[lat1, lng1], [lat2, lng2], [lat3, lng3], [lat4, lng4]]
            );
            DMSConsole.log(`‚úÖ Container caricato: 4 punti`, 'success');
          }
          
          // Carica plant rotation e scale (supporta entrambi i formati)
          if (jsonData.plantRotation !== undefined || jsonData.plant_rotation !== undefined) {
            plantRotation = jsonData.plantRotation || jsonData.plant_rotation;
            const rotationEl = document.getElementById('rotation-value');
            if (rotationEl) {
              rotationEl.textContent = plantRotation.toFixed(1) + '¬∞';
            }
            DMSConsole.log(`‚úÖ Rotazione: ${plantRotation.toFixed(1)}¬∞`, 'success');
          }
          
          if (jsonData.scale !== undefined || jsonData.plant_scale !== undefined) {
            plantScale = jsonData.scale || jsonData.plant_scale;
            const scaleEl = document.getElementById('scale-value');
            if (scaleEl) {
              scaleEl.textContent = Math.round(plantScale * 100) + '%';
            }
            DMSConsole.log(`‚úÖ Scala: ${Math.round(plantScale * 100)}%`, 'success');
          }
          
          // ===== CARICA POSTEGGI - SUPPORTA DUE FORMATI =====
          
          // Formato 1: stalls_geojson (GeoJSON FeatureCollection) - NUOVO!
          if (jsonData.stalls_geojson && jsonData.stalls_geojson.features) {
            DMSConsole.log(`üì¶ Formato GeoJSON rilevato: ${jsonData.stalls_geojson.features.length} features`, 'info');
            
            jsonData.stalls_geojson.features.forEach((feature, index) => {
              const props = feature.properties;
              const [lng, lat] = feature.geometry.coordinates;
              
              // Estrai dimensioni da properties.dimensions (es: "4.0m √ó 8.0m")
              let width = 2.5, height = 5.0;
              if (props.dimensions) {
                const match = props.dimensions.match(/([\d.]+)m\s*[√óx]\s*([\d.]+)m/);
                if (match) {
                  width = parseFloat(match[1]);
                  height = parseFloat(match[2]);
                }
              }
              
              const slot = {
                number: props.number || (index + 1),
                lat: lat,
                lng: lng,
                width: width,
                height: height,
                rotation: props.orientation || 0
              };
              
              slots.push(slot);
              
              // Disegna posteggio sulla mappa
              const center = { lat, lng };
              const corners = calculateSlotBounds(center, width, height, slot.rotation);
              
              const rect = L.polygon(corners, {
                color: '#14b8a6',
                fillColor: '#14b8a6',
                fillOpacity: 0.3,
                weight: 2
              });
              
              rect.bindPopup(`<b>Posteggio ${slot.number}</b><br>${slot.width}m √ó ${slot.height}m<br>Rotazione: ${slot.rotation.toFixed(1)}¬∞`);
              rect.addTo(map);
              slot.polygon = rect;
            });
            
            DMSConsole.log(`‚úÖ ${jsonData.stalls_geojson.features.length} posteggi caricati da stalls_geojson`, 'success');
          }
          // Formato 2: stalls (array semplice) - VECCHIO
          else if (jsonData.stalls && Array.isArray(jsonData.stalls)) {
            DMSConsole.log(`üì¶ Formato array semplice rilevato: ${jsonData.stalls.length} stalls`, 'info');
            
            jsonData.stalls.forEach((stall, index) => {
              // Estrai dimensioni da properties.dimensions (es: "2.5m √ó 5.0m")
              let width = 2.5, height = 5.0;
              if (stall.properties && stall.properties.dimensions) {
                const match = stall.properties.dimensions.match(/([\d.]+)m\s*[√óx]\s*([\d.]+)m/);
                if (match) {
                  width = parseFloat(match[1]);
                  height = parseFloat(match[2]);
                }
              }
              
              const slot = {
                number: stall.properties.number || (index + 1),
                lat: stall.geometry.coordinates[1],
                lng: stall.geometry.coordinates[0],
                width: width,
                height: height,
                rotation: stall.properties.orientation || 0
              };
              
              slots.push(slot);
              
              // Disegna posteggio sulla mappa
              const center = { lat: slot.lat, lng: slot.lng };
              const corners = calculateSlotBounds(center, width, height, slot.rotation);
              
              const rect = L.polygon(corners, {
                color: '#14b8a6',
                fillColor: '#14b8a6',
                fillOpacity: 0.3,
                weight: 2
              });
              
              rect.bindPopup(`<b>Posteggio ${slot.number}</b><br>${slot.width}m √ó ${slot.height}m`);
              rect.addTo(map);
              slot.polygon = rect;
            });
            
            DMSConsole.log(`‚úÖ ${jsonData.stalls.length} posteggi caricati da stalls`, 'success');
          }
          
          // ===== CARICA MARKER - SUPPORTA DUE FORMATI =====
          
          // Formato 1: markers_geojson (GeoJSON FeatureCollection) - NUOVO!
          if (jsonData.markers_geojson && jsonData.markers_geojson.features) {
            DMSConsole.log(`üìç Formato marker GeoJSON rilevato: ${jsonData.markers_geojson.features.length} features`, 'info');
            
            jsonData.markers_geojson.features.forEach((feature, index) => {
              const props = feature.properties;
              const [lng, lat] = feature.geometry.coordinates;
              
              const m = {
                number: props.number || (index + 1),
                letter: props.letter || 'M',
                name: props.name || `Marker ${index + 1}`,
                type: props.type || 'shop',
                lat: lat,
                lng: lng,
                size: props.size || 30,
                bgColor: props.bgColor || '#4caf50',
                textColor: props.textColor || '#ffffff',
                borderColor: props.borderColor || '#2e7d32',
                borderWidth: props.borderWidth || 3,
                description: props.description || ''
              };
              
              markers.push(m);
              
              // Disegna marker sulla mappa
              const markerIcon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="
                  background: ${m.bgColor}; 
                  color: ${m.textColor}; 
                  width: ${m.size}px; 
                  height: ${m.size}px; 
                  border: ${m.borderWidth}px solid ${m.borderColor};
                  border-radius: 50%;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                  font-weight: bold;
                  font-size: ${m.size * 0.5}px;
                ">${m.letter}</div>`,
                iconSize: [m.size, m.size]
              });
              
              const leafletMarker = L.marker([m.lat, m.lng], { icon: markerIcon });
              leafletMarker.bindPopup(`<b>${m.name}</b><br>${m.description}<br><small>Tipo: ${m.type}</small>`);
              leafletMarker.addTo(map);
              m.leafletMarker = leafletMarker;
            });
            
            DMSConsole.log(`‚úÖ ${jsonData.markers_geojson.features.length} marker caricati da markers_geojson`, 'success');
          }
          // Formato 2: markers (array semplice) - VECCHIO
          else if (jsonData.markers && Array.isArray(jsonData.markers)) {
            DMSConsole.log(`üìç Formato marker array semplice rilevato: ${jsonData.markers.length} markers`, 'info');
            jsonData.markers.forEach((marker, index) => {
              const m = {
                number: index + 1,
                name: marker.properties.name || `Marker ${index + 1}`,
                type: marker.properties.type || 'info',
                lat: marker.geometry.coordinates[1],
                lng: marker.geometry.coordinates[0],
                bgColor: marker.properties.color || '#3b82f6',
                description: marker.properties.description || ''
              };
              
              markers.push(m);
              
              // Disegna marker sulla mappa
              const markerIcon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="background: ${m.bgColor}; color: white; padding: 5px; border-radius: 5px;">${m.type.charAt(0).toUpperCase()}</div>`
              });
              
              const leafletMarker = L.marker([m.lat, m.lng], { icon: markerIcon });
              leafletMarker.bindPopup(`<b>${m.name}</b><br>${m.description}`);
              leafletMarker.addTo(map);
              m.leafletMarker = leafletMarker;  // Salva riferimento per rimozione futura
            });
            
            DMSConsole.log(`‚úÖ ${jsonData.markers.length} marker caricati`, 'success');
          }
          
          // ===== CARICA AREE - SUPPORTA DUE FORMATI =====
          
          // Formato 1: areas_geojson (GeoJSON FeatureCollection) - NUOVO!
          if (jsonData.areas_geojson && jsonData.areas_geojson.features) {
            DMSConsole.log(`üìê Formato aree GeoJSON rilevato: ${jsonData.areas_geojson.features.length} features`, 'info');
            
            jsonData.areas_geojson.features.forEach((feature, index) => {
              const props = feature.properties;
              const coords = feature.geometry.coordinates[0].map(c => [c[1], c[0]]);
              
              const a = {
                number: props.number || (index + 1),
                name: props.name || `Area ${index + 1}`,
                type: props.type || 'market',
                coordinates: coords,
                fillColor: props.fillColor || '#4caf50',
                fillOpacity: props.fillOpacity || 0.01,
                borderColor: props.borderColor || '#2e7d32',
                borderWidth: props.borderWidth || 3,
                description: props.description || ''
              };
              
              areas.push(a);
              
              // Disegna area sulla mappa
              const polygon = L.polygon(coords, {
                color: a.borderColor,
                fillColor: a.fillColor,
                fillOpacity: a.fillOpacity,
                weight: a.borderWidth
              });
              
              polygon.bindPopup(`<b>${a.name}</b><br>${a.description}<br><small>Tipo: ${a.type}</small>`);
              polygon.addTo(map);
              a.polygon = polygon;
            });
            
            DMSConsole.log(`‚úÖ ${jsonData.areas_geojson.features.length} aree caricate da areas_geojson`, 'success');
          }
          // Formato 2: areas (array semplice) - VECCHIO
          else if (jsonData.areas && Array.isArray(jsonData.areas)) {
            DMSConsole.log(`üìê Formato aree array semplice rilevato: ${jsonData.areas.length} areas`, 'info');
            jsonData.areas.forEach((area, index) => {
              const coords = area.geometry.coordinates[0].map(c => [c[1], c[0]]);
              
              const a = {
                number: index + 1,
                name: area.properties.name || `Area ${index + 1}`,
                type: area.properties.type || 'zone',
                coordinates: coords,
                fillColor: area.properties.color || '#10b981',
                fillOpacity: area.properties.opacity || 0.3,
                description: area.properties.description || ''
              };
              
              areas.push(a);
              
              // Disegna area sulla mappa
              const polygon = L.polygon(coords, {
                color: a.fillColor,
                fillColor: a.fillColor,
                fillOpacity: a.fillOpacity,
                weight: 2
              });
              
              polygon.bindPopup(`<b>${a.name}</b><br>${a.description}`);
              polygon.addTo(map);
              a.polygon = polygon;  // Salva riferimento per rimozione futura
            });
            
            DMSConsole.log(`‚úÖ ${jsonData.areas.length} aree caricate`, 'success');
          }
          
          // Aggiorna UI
          updateSlotList();
          updateMarkerList();
          updateAreaList();
          
          // Centra mappa sui posteggi caricati
          if (slots.length > 0) {
            const avgLat = slots.reduce((sum, s) => sum + s.lat, 0) / slots.length;
            const avgLng = slots.reduce((sum, s) => sum + s.lng, 0) / slots.length;
            map.setView([avgLat, avgLng], 18);
          }
          
          document.getElementById('import-status').textContent = `‚úÖ Caricati: ${slots.length} posteggi, ${markers.length} marker, ${areas.length} aree`;
          DMSConsole.log(`üéâ Import completato con successo!`, 'success');
          alert(`‚úÖ Import completato!\n\nüìä Dati caricati:\n- ${slots.length} posteggi\n- ${markers.length} marker\n- ${areas.length} aree\n\nüó∫Ô∏è Ora puoi esportare verso Dashboard Admin!`);
          
        } catch (error) {
          console.error('Errore parsing JSON:', error);
          DMSConsole.log(`‚ùå Errore import: ${error.message}`, 'error');
          document.getElementById('import-status').textContent = `‚ùå Errore: ${error.message}`;
          alert(`‚ùå Errore durante l'import!\n\n${error.message}\n\nVerifica che il file JSON sia nel formato corretto.`);
        }
      };
      
      reader.onerror = () => {
        DMSConsole.log('‚ùå Errore lettura file', 'error');
        document.getElementById('import-status').textContent = '‚ùå Errore lettura file';
      };
      
      reader.readAsText(file);
    });
    
    // Salva nel Bus
    document.getElementById('btn-save-bus').addEventListener('click', async () => {
      if (slots.length === 0) {
        alert('‚ö†Ô∏è Aggiungi almeno un posteggio prima di salvare!');
        return;
      }
      
      try {
        // Salva posteggi
        const stallsGeoJSON = {
          type: 'FeatureCollection',
          features: slots.map(slot => ({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [slot.lng, slot.lat]
            },
            properties: {
              number: slot.number,
              orientation: slot.rotation,
              kind: 'slot',
              status: 'free',
              dimensions: `${slot.width}m √ó ${slot.height}m`
            }
          }))
        };
        
        await DMSBUS.set('stalls_geojson', JSON.stringify(stallsGeoJSON));
        
        // Salva container se disponibile
        if (plantBounds) {
          const corners = [
            [plantBounds.getNorthWest().lat, plantBounds.getNorthWest().lng],
            [plantBounds.getNorthEast().lat, plantBounds.getNorthEast().lng],
            [plantBounds.getSouthEast().lat, plantBounds.getSouthEast().lng],
            [plantBounds.getSouthWest().lat, plantBounds.getSouthWest().lng]
          ];
          await DMSBUS.set('container', JSON.stringify(corners));
        }
        
        // Salva PNG se disponibile
        if (pdfBlob) {
          await DMSBUS.setBlob('png_transparent', pdfBlob);
        }
        
        document.getElementById('export-status').textContent = `‚úÖ Salvato nel Bus!`;
        DMSConsole.log(`‚úÖ ${slots.length} posteggi salvati nel BUS`);
        alert(`‚úÖ ${slots.length} posteggi salvati nel BUS!`);
      } catch (err) {
        alert('‚ùå Errore salvataggio: ' + err.message);
        DMSConsole.log('‚ùå Errore: ' + err.message);
      }
    });
    
    // Reset Pianta Completo
    document.getElementById('btn-reset-plant').addEventListener('click', () => {
      const confirmed = confirm(
        'üßπ RESET PIANTA COMPLETO\n\n' +
        'Questa azione canceller√† DEFINITIVAMENTE:\n' +
        '- Tutti i posteggi salvati\n' +
        '- Tutti i marker personalizzati\n' +
        '- Tutte le aree disegnate\n' +
        '- La pianta caricata\n' +
        '- La posizione del segnaposto\n\n' +
        '‚ö†Ô∏è AZIONE IRREVERSIBILE!\n\n' +
        'Sei sicuro di voler procedere?'
      );
      
      if (!confirmed) {
        return;
      }
      
      // Seconda conferma per sicurezza
      const doubleConfirm = confirm(
        '‚ö†Ô∏è ULTIMA CONFERMA\n\n' +
        'Stai per cancellare TUTTI i dati salvati.\n' +
        'Questa operazione NON pu√≤ essere annullata.\n\n' +
        'Continuare?'
      );
      
      if (!doubleConfirm) {
        return;
      }
      
      try {
        // Cancella localStorage
        localStorage.removeItem('plant_marker_position');
        localStorage.removeItem('slots_positions');
        
        // Cancella anche eventuali altre chiavi (per sicurezza)
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && (key.includes('plant') || key.includes('slot') || key.includes('stall') || key.includes('marker') || key.includes('area'))) {
            keysToRemove.push(key);
          }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
        
        console.log('üßπ localStorage pulito:', keysToRemove);
        
        // Mostra messaggio di successo
        alert(
          '‚úÖ RESET COMPLETATO!\n\n' +
          'Tutti i dati sono stati cancellati.\n' +
          'La pagina verr√† ricaricata per iniziare da zero.'
        );
        
        // Ricarica la pagina per applicare il reset
        window.location.reload();
        
      } catch (err) {
        alert('‚ùå Errore durante il reset: ' + err.message);
        console.error('Errore reset:', err);
      }
    });
  </script>
  
  <!-- Console Log Panel -->
  <div id="console-panel" style="position: fixed; bottom: 20px; right: 20px; width: 400px; max-height: 300px; background: rgba(30, 41, 59, 0.95); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10000; font-family: 'Courier New', monospace; display: flex; flex-direction: column;">
    <div id="console-header" style="padding: 10px 15px; background: rgba(15, 23, 42, 0.9); border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center; cursor: move; user-select: none;">
      <span style="color: #10b981; font-weight: bold; font-size: 13px;">üìü Console Log</span>
      <div style="display: flex; gap: 8px;">
        <button id="btn-console-minimize" style="background: #fbbf24; color: #000; border: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; font-size: 10px; padding: 0; line-height: 1;">‚àí</button>
        <button id="btn-console-close" style="background: #ef4444; color: #fff; border: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; font-size: 10px; padding: 0; line-height: 1;">‚úï</button>
      </div>
    </div>
    <div id="console-content" style="flex: 1; overflow-y: auto; padding: 10px; font-size: 11px; line-height: 1.5; color: #e2e8f0; max-height: 250px;">
      <!-- Log messages will appear here -->
    </div>
  </div>
  
  <script>
    // DMSConsole object for logging
    const DMSConsole = {
      panel: null,
      content: null,
      minimized: false,
      
      init() {
        this.panel = document.getElementById('console-panel');
        this.content = document.getElementById('console-content');
        
        // Minimize/Maximize
        document.getElementById('btn-console-minimize').addEventListener('click', () => {
          this.minimized = !this.minimized;
          this.content.style.display = this.minimized ? 'none' : 'block';
          document.getElementById('btn-console-minimize').textContent = this.minimized ? '+' : '‚àí';
        });
        
        // Close
        document.getElementById('btn-console-close').addEventListener('click', () => {
          this.panel.style.display = 'none';
        });
        
        // Make draggable
        const header = document.getElementById('console-header');
        let isDragging = false;
        let currentX, currentY, initialX, initialY;
        
        header.addEventListener('mousedown', (e) => {
          isDragging = true;
          initialX = e.clientX - this.panel.offsetLeft;
          initialY = e.clientY - this.panel.offsetTop;
        });
        
        document.addEventListener('mousemove', (e) => {
          if (isDragging) {
            e.preventDefault();
            currentX = e.clientX - initialX;
            currentY = e.clientY - initialY;
            this.panel.style.left = currentX + 'px';
            this.panel.style.top = currentY + 'px';
            this.panel.style.right = 'auto';
            this.panel.style.bottom = 'auto';
          }
        });
        
        document.addEventListener('mouseup', () => {
          isDragging = false;
        });
      },
      
      log(message, type = 'info') {
        if (!this.content) return;
        
        const timestamp = new Date().toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const icons = {
          info: 'üîµ',
          success: '‚úÖ',
          error: '‚ùå',
          warning: '‚ö†Ô∏è',
          search: 'üîç',
          save: 'üíæ'
        };
        const icon = icons[type] || 'üîµ';
        
        const logEntry = document.createElement('div');
        logEntry.style.marginBottom = '4px';
        logEntry.style.paddingBottom = '4px';
        logEntry.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
        logEntry.innerHTML = `
          <span style="color: #94a3b8; font-size: 10px;">${timestamp}</span>
          <span style="margin: 0 5px;">${icon}</span>
          <span style="color: ${type === 'error' ? '#fca5a5' : type === 'warning' ? '#fde047' : type === 'success' ? '#86efac' : '#e2e8f0'};">${message}</span>
        `;
        
        this.content.appendChild(logEntry);
        this.content.scrollTop = this.content.scrollHeight;
        
        // Limit to 50 messages
        while (this.content.children.length > 50) {
          this.content.removeChild(this.content.firstChild);
        }
      }
    };
    
    // Initialize console on page load
    document.addEventListener('DOMContentLoaded', () => {
      DMSConsole.init();
      DMSConsole.log('Slot Editor v3 inizializzato', 'success');
    });
  </script>
</body>
</html>
